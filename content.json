{"meta":{"title":"我的博客 - blog","subtitle":"驿站小憩","description":"脑容量不够，笔记来凑","author":"unistd68","url":"https://blog.xtcgch.ink"},"pages":[{"title":"","date":"2020-08-10T10:46:28.867Z","updated":"2018-11-25T02:34:13.891Z","comments":true,"path":"404.html","permalink":"https://blog.xtcgch.ink/404.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-22T09:35:24.000Z","updated":"2018-11-22T09:36:05.345Z","comments":true,"path":"tags/index.html","permalink":"https://blog.xtcgch.ink/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-22T09:35:00.000Z","updated":"2018-11-22T09:36:45.833Z","comments":true,"path":"categories/index.html","permalink":"https://blog.xtcgch.ink/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"IO模型","slug":"20201103-IO模型","date":"2020-11-22T14:13:36.000Z","updated":"2020-11-22T16:06:29.597Z","comments":true,"path":"IO模型/","link":"","permalink":"https://blog.xtcgch.ink/IO模型/","excerpt":"摘要：记录IO模型的相关知识。","text":"摘要：记录IO模型的相关知识。 脑图 date: 2020-11-03 18:13:36IO模型 阻塞式IO 非阻塞式IO IO复用 select poll 信号驱动式IO SIGIO 异步IO POSIX的aio_系列函数 阻塞式IO 函数：recv()。调用者所在的线程会被recv函数所阻塞，知道recv函数返回结果，而recv函数直到接收到对端发来数据后才会返回。 非阻塞式IO 函数：recvfrom()。recvfrom函数在被调用后,无论是否接收到数据,都会立刻返回,没有接收到数据时返回值：EWOULDBLOCK。 IO复用在调用recv前先调用select或者poll,这2个系统调用都可以在内核准备好数据(网络数据到达内核)时告知用户进程，这个时候再调用recv一定是有数据的。因此这一过程中它是阻塞于select或poll，而没有阻塞于recv。 信号驱动式IO通过调用sigaction注册信号函数，等内核数据准备好的时候系统中断当前程序，执行信号函数(在这里面调用recv) 异步IO调用aio_read，让内核等数据准备好，并且复制到用户进程空间后执行事先指定好的函数。 benchmark 比较IO模型比较同步和异步IO比较 select select的优缺点优点：（1）select的可移植性好，在某些unix下不支持poll.（2）select对超时值提供了很好的精度，精确到微秒，而poll式毫秒。缺点：（1）单个进程可监视的fd数量被限制，默认是1024。（2）需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。（3）对fd进行扫描时是线性扫描，fd剧增后，IO效率降低，每次调用都对fd进行线性扫描遍历，随着fd的增加会造成遍历速度慢的问题。（4）select函数超时参数在返回时也是未定义的，考虑到可移植性，每次超时之后进入下一个select之前都要重新设置超时参数 select函数介绍 int select(int maxfdp,fd_set *readfds,fd_set *writefds,fd_set *errorfds,struct timeval *timeout); 参数介绍 maxfdp : 需要监视的最大文件描述符加1 readfds、writefds、errorfds：分别对应于需要检测的可读文件描述符的集合，可写文件描述符的集 合及异常文件描述符的集合。 timeout：等待时间，这个时间内，需要监视的描述符没有事件发⽣生则函数返回，返回值为0。设为NULL 表示阻塞式等待，一直等到有事件就绪，函数才会返回，0表示非阻塞式等待，没有事件就立即返回，大于0表示等待的时间 返回值 大于0：表示就绪时间的个数 等于0：表示timeout等待时间到了 小于0：表示调用失 demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157#include&lt;stdio.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;unistd.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;sys/time.h&gt;static void Usage(const char* proc)&#123; printf(&quot;%s [local_ip] [local_port]\\n&quot;,proc);&#125;int array[4096];static int start_up(const char* _ip,int _port)&#123; int sock = socket(AF_INET,SOCK_STREAM,0); if(sock &lt; 0) &#123; perror(&quot;socket&quot;); exit(1); &#125; struct sockaddr_in local; local.sin_family = AF_INET; local.sin_port = htons(_port); local.sin_addr.s_addr = inet_addr(_ip); if(bind(sock,(struct sockaddr*)&amp;local,sizeof(local)) &lt; 0) &#123; perror(&quot;bind&quot;); exit(2); &#125; if(listen(sock,10) &lt; 0) &#123; perror(&quot;listen&quot;); exit(3); &#125; return sock;&#125;int main(int argc,char* argv[])&#123; if(argc != 3) &#123; Usage(argv[0]); return -1; &#125; int listensock = start_up(argv[1],atoi(argv[2])); int maxfd = 0; fd_set rfds; fd_set wfds; array[0] = listensock; int i = 1; int array_size = sizeof(array)/sizeof(array[0]); for(; i &lt; array_size;i++) &#123; array[i] = -1; &#125; while(1) &#123; FD_ZERO(&amp;rfds); FD_ZERO(&amp;wfds); for(i = 0;i &lt; array_size;++i) &#123; if(array[i] &gt; 0) &#123; FD_SET(array[i],&amp;rfds); FD_SET(array[i],&amp;wfds); if(array[i] &gt; maxfd) &#123; maxfd = array[i]; &#125; &#125; &#125; switch(select(maxfd + 1,&amp;rfds,&amp;wfds,NULL,NULL)) &#123; case 0: &#123; printf(&quot;timeout\\n&quot;); break; &#125; case -1: &#123; perror(&quot;select&quot;); break; &#125; default: &#123; int j = 0; for(; j &lt; array_size; ++j) &#123; if(j == 0 &amp;&amp; FD_ISSET(array[j],&amp;rfds)) &#123; //listensock happened read events struct sockaddr_in client; socklen_t len = sizeof(client); int new_sock = accept(listensock,(struct sockaddr*)&amp;client,&amp;len); if(new_sock &lt; 0)//accept failed &#123; perror(&quot;accept&quot;); continue; &#125; else//accept success &#123; printf(&quot;get a new client%s\\n&quot;,inet_ntoa(client.sin_addr)); fflush(stdout); int k = 1; for(; k &lt; array_size;++k) &#123; if(array[k] &lt; 0) &#123; array[k] = new_sock; if(new_sock &gt; maxfd) maxfd = new_sock; break; &#125; &#125; if(k == array_size) &#123; close(new_sock); &#125; &#125; &#125;//j == 0 else if(j != 0 &amp;&amp; FD_ISSET(array[j], &amp;rfds)) &#123; //new_sock happend read events char buf[1024]; ssize_t s = read(array[j],buf,sizeof(buf) - 1); if(s &gt; 0)//read success &#123; buf[s] = 0; printf(&quot;clientsay#%s\\n&quot;,buf); if(FD_ISSET(array[j],&amp;wfds)) &#123; const char *msg = &quot;HTTP/1.0 200 OK &lt;\\r\\n\\r\\n&lt;html&gt;&lt;h1&gt;yingying beautiful&lt;/h1&gt;&lt;/html&gt;\\r\\n&quot;; write(array[j],msg,strlen(msg)); &#125; &#125; else if(0 == s) &#123; printf(&quot;client quit!\\n&quot;); close(array[j]); array[j] = -1; &#125; else &#123; perror(&quot;read&quot;); close(array[j]); array[j] = -1; &#125; &#125;//else j != 0 &#125; break; &#125; &#125; &#125; return 0;&#125; poll poll函数的优缺点优点：（1）不要求计算最大文件描述符+1的大小。（2）应付大数量的文件描述符时比select要快。（3）没有最大连接数的限制是基于链表存储的。缺点：（1）大量的fd数组被整体复制于内核态和用户态之间，而不管这样的复制是不是有意义。（2）同select相同的是调用结束后需要轮询来获取就绪描述符 poll函数介绍 int poll ( struct pollfd * fds, unsigned int nfds, int timeout); 参数介绍 fds : 对应上述介绍的结构体指针 nfds : 标记数组中结构体元素的总个数。 timeout : 超时时间 ，等于0表示非阻塞式等待，小于0表示阻塞式等待，大于0表示等待的时间。 返回值： 成功时返回fds数组中事件就绪的文件描述符的个数 0：表示超时时间到了。 -1：表示调用失败，对应的错误码会被设置。 demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include&lt;stdio.h&gt;#include &lt;unistd.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;poll.h&gt;static void usage(const char *proc)&#123; printf(&quot;%s [local_ip] [local_port]\\n&quot;,proc);&#125;int start_up(const char*_ip,int _port)&#123; int sock = socket(AF_INET,SOCK_STREAM,0); if(sock &lt; 0) &#123; perror(&quot;socket&quot;); return 2; &#125; int opt = 1; setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,&amp;opt,sizeof(opt)); struct sockaddr_in local; local.sin_family = AF_INET; local.sin_port = htons(_port); local.sin_addr.s_addr = inet_addr(_ip); if(bind(sock,(struct sockaddr*)&amp;local,sizeof(local)) &lt; 0) &#123; perror(&quot;bind&quot;); return 3; &#125; if(listen(sock,10) &lt; 0) &#123; perror(&quot;listen&quot;); return 4; &#125; return sock;&#125;int main(int argc, char*argv[])&#123; if(argc != 3) &#123; usage(argv[0]); return 1; &#125; int sock = start_up(argv[1],atoi(argv[2])); struct pollfd peerfd[1024]; peerfd[0].fd = sock; peerfd[0].events = POLLIN; int nfds = 1; int ret; int maxsize = sizeof(peerfd)/sizeof(peerfd[0]); int i = 1; int timeout = -1; for(; i &lt; maxsize; ++i) &#123; peerfd[i].fd = -1; &#125; while(1) &#123; switch(ret = poll(peerfd,nfds,timeout)) &#123; case 0: printf(&quot;timeout...\\n&quot;); break; case -1: perror(&quot;poll&quot;); break; default: &#123; if(peerfd[0].revents &amp; POLLIN) &#123; struct sockaddr_in client; socklen_t len = sizeof(client); int new_sock = accept(sock,\\ (struct sockaddr*)&amp;client,&amp;len); printf(&quot;accept finish %d\\n&quot;,new_sock); if(new_sock &lt; 0) &#123; perror(&quot;accept&quot;); continue; &#125; printf(&quot;get a new client\\n&quot;); int j = 1; for(; j &lt; maxsize; ++j) &#123; if(peerfd[j].fd &lt; 0) &#123; peerfd[j].fd = new_sock; break; &#125; &#125; if(j == maxsize) &#123; printf(&quot;to many clients...\\n&quot;); close(new_sock); &#125; peerfd[j].events = POLLIN; if(j + 1 &gt; nfds) nfds = j + 1; &#125; for(i = 1;i &lt; nfds;++i) &#123; if(peerfd[i].revents &amp; POLLIN) &#123; printf(&quot;read ready\\n&quot;); char buf[1024]; ssize_t s = read(peerfd[i].fd,buf, \\ sizeof(buf) - 1); if(s &gt; 0) &#123; buf[s] = 0; printf(&quot;client say#%s&quot;,buf); fflush(stdout); peerfd[i].events = POLLOUT; &#125; else if(s &lt;= 0) &#123; close(peerfd[i].fd); peerfd[i].fd = -1; &#125; else &#123; &#125; &#125;//i != 0 else if(peerfd[i].revents &amp; POLLOUT) &#123; const char *msg = &quot;HTTP/1.0 200 OK \\ &lt;\\r\\n\\r\\n&lt;html&gt;&lt;h1&gt; \\ yingying beautiful \\ &lt;/h1&gt;&lt;/html&gt;\\r\\n&quot;; write(peerfd[i].fd,msg,strlen(msg)); close(peerfd[i].fd); peerfd[i].fd = -1; &#125; else &#123; &#125; &#125;//for &#125;//default break; &#125; &#125; return 0;&#125; epoll epoll函数的优缺点优点：epoll的优点：（1）支持一个进程打开大数目的socket描述符(FD)select 最不能忍受的是一个进程所打开的FD是有一定限制的，由FD_SETSIZE设置，默认值是2048。对于那些需要支持的上万连接数目的IM服务器来说显 然太少了。这时候你一是可以选择修改这个宏然后重新编译内核，不过资料也同时指出这样会带来网络效率的下降，二是可以选择多进程的解决方案(传统的 Apache方案)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完 美的方案。不过 epoll则没有这个限制，它所支持的FD上限是最大可以打开文件的数目，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。（2）IO效率不随FD数目增加而线性下降传统的select/poll另一个致命弱点就是当你拥有一个很大的socket集合，不过由于网络延时，任一时间只有部分的socket是”活跃”的， 但是select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。但是epoll不存在这个问题，它只会对”活跃”的socket进行 操作—这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有”活跃”的socket才会主动的去调用 callback函数，其他idle状态socket则不会，在这点上，epoll实现了一个”伪”AIO，因为这时候推动力在os内核。在一些 benchmark中，如果所有的socket基本上都是活跃的—比如一个高速LAN环境，epoll并不比select/poll有什么效率，相 反，如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select/poll之上了。（3）使用mmap加速内核与用户空间的消息传递。这点实际上涉及到epoll的具体实现了。无论是select,poll还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就 很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的。而如果你想我一样从2.5内核就关注epoll的话，一定不会忘记手工 mmap这一步的。（4）内核微调这一点其实不算epoll的优点了，而是整个linux平台的优点。也许你可以怀疑linux平台，但是你无法回避linux平台赋予你微调内核的能力。 比如，内核TCP/IP协议栈使用内存池管理sk_buff结构，那么可以在运行时期动态调整这个内存pool(skb_head_pool)的大小 — 通过echo XXXX&gt;/proc/sys/net/core/hot_list_length完成。再比如listen函数的第2个参数(TCP完成3次握手 的数据包队列长度)，也可以根据你平台内存大小动态调整。更甚至在一个数据包面数目巨大但同时每个数据包本身大小却很小的特殊系统上尝试最新的NAPI网 卡驱动架构 epoll函数相关系统调用 int epoll_create(int size); int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event ); epfd : epoll的专用描述符。 op : 相关操作，通常用以下宏来表示 event ： 通知内核需要监听的事件 EPOLL_CTL_ADD：注册新的fd到epfd中 EPOLL_CTL_MOD：修改已经注册的fd的监听事件 EPOLL_CTL_DEL：从epfd中删除⼀一个fd fd : 需要监听的事件 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout) demo: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;stdio.h&gt;#include &lt;unistd.h&gt;#include&lt;sys/types.h&gt;#include&lt;sys/socket.h&gt;#include&lt;netinet/in.h&gt;#include&lt;arpa/inet.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;sys/epoll.h&gt;static void usage_info(const char* proc)&#123; printf(&quot;%s [local_ip] [local_port]\\n&quot;,proc);&#125;int start_up(const char*_ip,int _port)&#123; int sock = socket(AF_INET,SOCK_STREAM,0); if(sock &lt; 0) &#123; perror(&quot;socket&quot;); exit(2); &#125; struct sockaddr_in local; local.sin_family = AF_INET; local.sin_port = htons(_port); local.sin_addr.s_addr = inet_addr(_ip); if(bind(sock,(struct sockaddr*)&amp;local,sizeof(local)) &lt; 0) &#123; perror(&quot;bind&quot;); exit(3); &#125; if(listen(sock,10)&lt; 0) &#123; perror(&quot;listen&quot;); exit(4); &#125; return sock;&#125;int main(int argc, char*argv[])&#123; if(argc != 3) &#123; usage_info(argv[0]); return 1; &#125; int sock = start_up(argv[1],atoi(argv[2])); int epollfd = epoll_create(256); if(epollfd &lt; 0) &#123; perror(&quot;epoll_create&quot;); return 5; &#125; struct epoll_event ev; ev.events = EPOLLIN; ev.data.fd = sock; if(epoll_ctl(epollfd,EPOLL_CTL_ADD,sock,&amp;ev) &lt; 0) &#123; perror(&quot;epoll_ctl&quot;); return 6; &#125; int evnums = 0;//epoll_wait return val struct epoll_event evs[64]; int timeout = -1; while(1) &#123; switch(evnums = epoll_wait(epollfd,evs,64,timeout)) &#123; case 0: printf(&quot;timeout...\\n&quot;); break; case -1: perror(&quot;epoll_wait&quot;); break;default: &#123; int i = 0; for(; i &lt; evnums; ++i) &#123; struct sockaddr_in client; socklen_t len = sizeof(client); if(evs[i].data.fd == sock \\ &amp;&amp; evs[i].events &amp; EPOLLIN) &#123; int new_sock = accept(sock, \\ (struct sockaddr*)&amp;client,&amp;len); if(new_sock &lt; 0) &#123; perror(&quot;accept&quot;); continue; &#125;//if accept failed else &#123; printf(&quot;Get a new client[%s]\\n&quot;, \\ inet_ntoa(client.sin_addr)); ev.data.fd = new_sock; ev.events = EPOLLIN; epoll_ctl(epollfd,EPOLL_CTL_ADD,\\ new_sock,&amp;ev); &#125;//accept success &#125;//if fd == sock else if(evs[i].data.fd != sock &amp;&amp; \\ evs[i].events &amp; EPOLLIN) &#123; char buf[1024]; ssize_t s = read(evs[i].data.fd,buf,sizeof(buf) - 1); if(s &gt; 0) &#123; buf[s] = 0; printf(&quot;client say#%s\\n&quot;,buf); ev.data.fd = evs[i].data.fd; ev.events = EPOLLOUT; epoll_ctl(epollfd,EPOLL_CTL_MOD, \\ evs[i].data.fd,&amp;ev); &#125;//s &gt; 0 else &#123; close(evs[i].data.fd); epoll_ctl(epollfd,EPOLL_CTL_DEL, \\ evs[i].data.fd,NULL); &#125; //printf(&quot;get a new message\\n&quot;); &#125;//fd != sock else if(evs[i].data.fd != sock \\ &amp;&amp; evs[i].events &amp; EPOLLOUT) &#123; printf(&quot;one client logout\\n&quot;); const char *msg = &quot;HTTP/1.0 200 OK &lt;\\r\\n\\r\\n&lt;html&gt;&lt;h1&gt;yingying beautiful &lt;/h1&gt;&lt;/html&gt;\\r\\n&quot;; write(evs[i].data.fd,msg,strlen(msg)); close(evs[i].data.fd); epoll_ctl(epollfd,EPOLL_CTL_DEL, \\ evs[i].data.fd,NULL); &#125;//EPOLLOUT else &#123; &#125; &#125;//for &#125;//default break; &#125;//switch &#125;//while return 0;&#125; 场景应用 总结 参考文章–&gt; 文章1–&gt; 文章1–&gt; 文章1","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://blog.xtcgch.ink/tags/IO/"},{"name":"linux","slug":"linux","permalink":"https://blog.xtcgch.ink/tags/linux/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"设计模式","slug":"20201122-设计模式","date":"2020-11-22T03:07:09.000Z","updated":"2020-11-22T15:50:16.212Z","comments":true,"path":"设计模式/","link":"","permalink":"https://blog.xtcgch.ink/设计模式/","excerpt":"摘要：这是摘要！","text":"摘要：这是摘要！ 脑图 单例模式工厂模式抽象工厂模式桥接模式组合模式迭代器模式解释器模式观察者模式模板模式工厂模式扩展点一 总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://blog.xtcgch.ink/tags/设计模式/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"面试题","slug":"20200902-面试题","date":"2020-09-02T02:03:55.000Z","updated":"2020-11-04T07:19:16.034Z","comments":true,"path":"面试题/","link":"","permalink":"https://blog.xtcgch.ink/面试题/","excerpt":"摘要：记录一下面试要点。","text":"摘要：记录一下面试要点。 脑图 基础原理类map和set有什么区别，分别又是怎么实现的 共同点map和set都是C++的关联容器，其底层实现都是红黑树（RB-Tree）。由于 map 和set所开放的各种操作接口，RB-tree 也都提供了，所以几乎所有的 map 和set的操作行为，都只是转调 RB-tree 的操作行为。 区别 map中的元素是key-value（关键字—值）对：关键字起到索引的作用，值则表示与索引相关联的数据；Set与之相对就是关键字的简单集合，set中每个元素只包含一个关键字。 set的迭代器是const的，不允许修改元素的值；map允许修改value，但不允许修改key。其原因是因为map和set是根据关键字排序来保证其有序性的，如果允许修改key的话，那么首先需要删除该键，然后调节平衡，再插入修改后的键值，调节平衡，如此一来，严重破坏了map和set的结构，导致iterator失效，不知道应该指向改变前的位置，还是指向改变后的位置。所以STL中将set的迭代器设置成const，不允许修改迭代器的值；而map的迭代器则不允许修改key值，允许修改value值。 map支持下标操作，set不支持下标操作。map可以用key做下标，map的下标运算符[ ]将关键码作为下标去执行查找，如果关键码不存在，则插入一个具有该关键码和mapped_type类型默认值的元素至map中，因此下标运算符[ ]在map应用中需要慎用，const_map不能用，只希望确定某一个关键值是否存在而不希望插入元素时也不应该使用，mapped_type类型没有默认值也不应该使用。如果find能解决需要，尽可能用find。 STL中MAP数据存放形式 无序的MAP是红黑树，unordered map底层结构是哈希表 Map映射，map 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。不允许键值重复。 底层实现：红黑树 适用场景：有序键值对不重复映射 Multimap多重映射。multimap 的所有元素都是 pair，同时拥有实值（value）和键值（key）。pair 的第一元素被视为键值，第二元素被视为实值。所有元素都会根据元素的键值自动被排序。允许键值重复。 底层实现：红黑树 适用场景：有序键值对可重复映射 epoll原理调用顺序：123int epoll_create(int size);int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);int epoll_wait(int epfd, struct epoll_event *events,int maxevents, int timeout); 首先创建一个epoll对象 使用epoll_ctl对这个对象进行操作，把需要监控的描述添加进去，这些描述如将会以epoll_event结构体的形式组成一颗红黑树 阻塞在epoll_wait，进入大循环，当某个fd上有事件发生时，内核将会把其对应的结构体放入到一个链表中，返回有事件发生的链表 malloc的原理，另外brk系统调用和mmap系统调用的作用分别是什么Malloc函数用于动态分配内存。为了减少内存碎片和系统调用的开销，malloc其采用内存池的方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，以块作为内存管理的基本单位。当用户申请内存时，直接从堆区分配一块合适的空闲块。Malloc采用隐式链表结构将堆区分成连续的、大小不一的块，包含已分配块和未分配块；同时malloc采用显示链表结构来管理所有的空闲块，即使用一个双向链表将空闲块连接起来，每一个空闲块记录了一个连续的、未分配的地址。当进行内存分配时，Malloc会通过隐式链表遍历所有的空闲块，选择满足要求的块进行分配；当进行内存合并时，malloc采用边界标记法，根据每个块的前后块是否已经分配来决定是否进行块合并。 Malloc在申请内存时，一般会通过brk或者mmap系统调用进行申请。其中当申请内存小于128K时，会使用系统函数brk在堆区中分配；而当申请内存大于128K时，会使用系统函数mmap在映射区分配。 C++的内存管理在C++中，虚拟内存分为代码段、数据段、BSS段、堆区、文件映射区以及栈区六部分。代码段:包括只读存储区和文本区，其中只读存储区存储字符串常量，文本区存储程序的机器代码。 数据段：存储程序中已初始化的全局变量和静态变量 bss 段：存储未初始化的全局变量和静态变量（局部+全局），以及所有被初始化为0的全局变量和静态变量。 堆区：调用new/malloc函数时在堆区动态分配内存，同时需要调用delete/free来手动释放申请的内存。 映射区:存储动态链接库以及调用mmap函数进行的文件映射 栈：使用栈空间存储函数的返回地址、参数、局部变量、返回值 C++的内存管理内存泄漏通常是由于调用了malloc/new等内存申请的操作，但是缺少了对应的free/delete。 linux环境下的内存泄漏检查工具Valgrind 在写代码时可以添加内存申请和释放的统计功能，统计当前申请和释放的内存是否一致 什么时候会发生段错误 使用野指针 试图修改字符串常量的内 什么是memory leak，也就是内存泄漏内存泄漏(memory leak)是指由于疏忽或错误造成了程序未能释放掉不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。内存泄漏的分类： 堆内存泄漏 （Heap leak）。对内存指的是程序运行中根据需要分配通过malloc,realloc new等从堆中分配的一块内存，再是完成后必须通过调用对应的 free或者delete 删掉。如果程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）。主要指程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉，导致系统资源的浪费，严重可导致系统效能降低，系统运行不稳定。 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露。 C++11有哪些新特性并发(concurrency)和并行(parallelism)并发（concurrency）：指宏观上看起来两个程序在同时运行，比如说在单核cpu上的多任务。但是从微观上看两个程序的指令是交织着运行的，你的指令之间穿插着我的指令，我的指令之间穿插着你的，在单个周期内只运行了一个指令。这种并发并不能提高计算机的性能，只能提高效率。 并行（parallelism）：指严格物理意义上的同时运行，比如多核cpu，两个程序分别运行在两个核上，两者之间互不影响，单个周期内每个程序都运行了自己的指令，也就是运行了两条指令。这样说来并行的确提高了计算机的效率。所以现在的cpu都是往多核方面发展。 单核机器上写多线程程序，是否需要考虑加锁在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突。 死锁发生的条件以及如何解决死锁死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象。死锁发生的四个必要条件如下： 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源； 请求和保持条件：进程获得一定的资源后，又对其他资源发出请求，但是该资源可能被其他进程占有，此时请求阻塞，但该进程不会释放自己已经占有的资源 不可剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放 环路等待条件：进程发生死锁后，必然存在一个进程-资源之间的环形链 解决死锁的方法即破坏上述四个条件之一，主要方法如下： 资源一次性分配，从而剥夺请求和保持条件 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，释放则相反，从而破坏环路等待的条件 操作系统中的结构体对齐，字节对齐1、原因：1）平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 2）性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。 2、规则 1）数据成员对齐规则：结构(struct)(或联合(union))的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行。 2）结构(或联合)的整体对齐规则：在数据成员完成各自对齐之后，结构(或联合)本身也要进行对齐，对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行。 3）结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。 3、定义结构体对齐 可以通过预编译命令#pragma pack(n)，n=1,2,4,8,16来改变这一系数，其中的n就是指定的“对齐系数”。 4、举例123456789101112131415#pragma pack(2)struct AA &#123;int a; //长度4 &gt; 2 按2对齐；偏移量为0；存放位置区间[0,3]char b; //长度1 &lt; 2 按1对齐；偏移量为4；存放位置区间[4]short c; //长度2 = 2 按2对齐；偏移量要提升到2的倍数6；存放位置区间[6,7]char d; //长度1 &lt; 2 按1对齐；偏移量为7；存放位置区间[8]；共九个字节&#125;;#pragma pack() 计算机网络类TCP怎么保证可靠性，并且简述一下TCP建立连接和断开连接的过程TCP保证可靠性：（1）序列号、确认应答、超时重传 数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送发迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。 （2）窗口控制与高速重发控制/快速重传（重复确认应答） TCP会利用窗口控制来提高传输速度，意思是在一个窗口大小内，不用一定要等到应答才能发送下一段数据，窗口大小就是无需等待确认而可以继续发送数据的最大值。如果不使用窗口控制，每一个没收到确认应答的数据都要重发。 使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒…… （3）拥塞控制 如果把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵（大家都在用网，你在这狂发，吞吐量就那么大，当然会堵），甚至造成网络的瘫痪。所以TCP在为了防止这种情况而进行了拥塞控制。 慢启动：定义拥塞窗口，一开始将该窗口大小设为1，之后每次收到确认应答（经过一个rtt），将拥塞窗口大小*2。 拥塞避免：设置慢启动阈值，一般开始都设为65536。拥塞避免是指当拥塞窗口大小达到这个阈值，拥塞窗口的值不再指数上升，而是加法增加（每次确认应答/每个rtt，拥塞窗口大小+1），以此来避免拥塞。 将报文段的超时重传看做拥塞，则一旦发生超时重传，我们需要先将阈值设为当前窗口大小的一半，并且将窗口大小设为初值1，然后重新进入慢启动过程。 快速重传：在遇到3次重复确认应答（高速重发控制）时，代表收到了3个报文段，但是这之前的1个段丢失了，便对它进行立即重传。 然后，先将阈值设为当前窗口大小的一半，然后将拥塞窗口大小设为慢启动阈值+3的大小。 这样可以达到：在TCP通信时，网络吞吐量呈现逐渐的上升，并且随着拥堵来降低吞吐量，再进入慢慢上升的过程，网络不会轻易的发生瘫痪。 三次握手： Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。 Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。 四次挥手： 由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。 1.数据传输结束后，客户端的应用进程发出连接释放报文段，并停止发送数据，客户端进入FIN_WAIT_1状态，此时客户端依然可以接收服务器发送来的数据。 2.服务器接收到FIN后，发送一个ACK给客户端，确认序号为收到的序号+1，服务器进入CLOSE_WAIT状态。客户端收到后进入FIN_WAIT_2状态。 3.当服务器没有数据要发送时，服务器发送一个FIN报文，此时服务器进入LAST_ACK状态，等待客户端的确认 4.客户端收到服务器的FIN报文后，给服务器发送一个ACK报文，确认序列号为收到的序号+1。此时客户端进入TIME_WAIT状态，等待2MSL（MSL：报文段最大生存时间），然后关闭连接 TCP的模型，状态转移操作系统中的中断中断是指CPU对系统发生的某个事件做出的一种反应，CPU暂停正在执行的程序，保存现场后自动去执行相应的处理程序，处理完该事件后再返回中断处继续执行原来的程序。 由CPU外部引起的，如I/O中断、时钟中断 来自CPU内部事件或程序执行中引起的中断，例如程序非法操作，地址越界、浮点溢出） 在程序中使用了系统调用引起的。而中断处理一般分为中断响应和中断处理两个步骤，中断响应由硬件实施，中断处理主要由软件实施。 TCP拥塞控制拥塞控制是防止过多的数据注入网络，使得网络中的路由器或者链路过载。流量控制是点对点的通信量控制，而拥塞控制是全局的网络流量整体性的控制。发送双方都有一个拥塞窗口——cwnd。1、慢开始 最开始发送方的拥塞窗口为1，由小到大逐渐增大发送窗口和拥塞窗口。每经过一个传输轮次，拥塞窗口cwnd加倍。当cwnd超过慢开始门限，则使用拥塞避免算法，避免cwnd增长过大。 2、拥塞避免 每经过一个往返时间RTT，cwnd就增长1。 在慢开始和拥塞避免的过程中，一旦发现网络拥塞，就把慢开始门限设为当前值的一半，并且重新设置cwnd为1，重新慢启动。（乘法减小，加法增大） 3、快重传 接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传（尽早重传未被确认的报文段）。 4、快恢复 当发送方连续收到了三个重复确认，就乘法减半（慢开始门限减半），将当前的cwnd设置为慢开始门限，并且采用拥塞避免算法（连续收到了三个重复请求，说明当前网络可能没有拥塞）。 采用快恢复算法时，慢开始只在建立连接和网络超时才使用。 达到什么情况的时候开始减慢增长的速度？ 采用慢开始和拥塞避免算法的时候 一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度 一旦出现丢包的情况，就重新进行慢开始，减慢增长速度 采用快恢复和快重传算法的时候 一旦cwnd&gt;慢开始门限，就采用拥塞避免算法，减慢增长速度 一旦发送方连续收到了三个重复确认，就采用拥塞避免算法，减慢增长速度 阻塞，非阻塞，同步，异步阻塞和非阻塞：调用者在事件没有发生的时候，一直在等待事件发生，不能去处理别的任务这是阻塞。调用者在事件没有发生的时候，可以去处理别的任务这是非阻塞。 同步和异步：调用者必须循环自去查看事件有没有发生，这种情况是同步。调用者不用自己去查看事件有没有发生，而是等待着注册在事件上的回调函数通知自己，这种情况是异步 数据库类数据库事物的一致性事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。事务是DBMS中最基础的单位，事务不可分割。事务具有4个基本特征，分别是：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Duration），简称ACID。 1）原子性（Atomicity） 原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，[删删删]因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。 2）一致性（Consistency） 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。 3）隔离性（Isolation） 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。 多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。 不同的隔离级别： Read Uncommitted（读取未提交[添加中文释义]内容）：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。 Read Committed（读取提交内容）：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。 Repeated Read（可重复读）：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。 Serialization（可串行化）：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。 4）持久性（Durability） 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。 例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误 数据库事物的一致性1）数据类型 ：redis数据类型丰富，支持set liset等类型；memcache支持简单数据类型，需要客户端自己处理复杂对象2）持久性：redis支持数据落地持久化存储；memcache不支持数据持久存储。) 3）分布式存储：redis支持master-slave复制模式；memcache可以使用一致性hash做分布式。 4）value大小不同：memcache是一个内存缓存，key的长度小于250字符，单个item存储要小于1M，不适合虚拟机使用 5）数据一致性不同：redis使用的是单线程模型，保证了数据按顺序提交；memcache需要使用cas保证数据一致性。CAS（Check and Set）是一个确保并发一致性的机制，属于“乐观锁”范畴；原理很简单：拿版本号，操作，对比版本号，如果一致就操作，不一致就放弃任何操作 6）cpu利用：redis单线程模型只能使用一个cpu，可以开启多个redis进程 linux强相关类select，epoll的区别Linux虚拟地址空间为了防止不同进程同一时刻在物理内存中运行而对物理内存的争夺和践踏，采用了虚拟内存。 虚拟内存技术使得不同进程在运行过程中，它所看到的是自己独自占有了当前系统的4G内存。所有进程共享同一物理内存，每个进程只把自己目前需要的虚拟内存空间映射并存储到物理内存上。 事实上，在每个进程创建加载时，内核只是为进程“创建”了虚拟内存的布局，具体就是初始化进程控制表中内存相关的链表，实际上并不立即就把虚拟内存对应位置的程序数据和代码（比如.text .data段）拷贝到物理内存中，只是建立好虚拟内存和磁盘文件之间的映射就好（叫做存储器映射），等到运行到对应的程序时，才会通过缺页异常，来拷贝数据。 还有进程运行过程中，要动态分配内存，比如malloc时，也只是分配了虚拟内存，即为这块虚拟内存对应的页表项做相应设置，当进程真正访问到此数据时，才引发缺页异常。 请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。 虚拟内存的好处： 1.扩大地址空间； 2.内存保护：每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。虚存还对特定的内存地址提供写保护，可以防止代码或数据被恶意篡改。 3.公平内存分配。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 4.当进程通信时，可采用虚存共享的方式实现。 5.当不同的进程使用同样的代码时，比如库文件中的代码，物理内存中可以只存储一份这样的代码，不同的进程只需要把自己的虚拟内存映射过去就可以了，节省内存 6.虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。在内存中可以保留多个进程，系统并发度提高 7.在程序需要分配连续的内存空间的时候，只需要在虚拟内存空间分配连续空间，而不需要实际物理内存的连续空间，可以利用碎片 虚拟内存的代价： 1.虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存 2.虚拟地址到物理地址的转换，增加了指令的执行时间。 3.页面的换入换出需要磁盘I/O，这是很耗时的 4.如果一页中只有一部分数据，会浪费内存。 fork和vfork的区别fork的基础知识：fork:创建一个和当前进程映像一样的进程可以通过fork( )系统调用： #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; pid_t fork(void); 成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错误，fork( )返回一个负值。 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。 在早期的Unix系统中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的方法，而不是对父进程空间进程整体复制。 vfork的基础知识： 在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用。 #include &lt;sys/types.h&gt; #include &lt;unistd.h&gt; pid_t vfork(void); 除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。因此，子进程也就不能修改地址空间中的任何内存。 vfork( )是一个历史遗留产物，Linux本不应该实现它。需要注意的是，即使增加了写时复制，vfork( )也要比fork( )快，因为它没有进行页表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork( )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可行的。 补充知识点：写时复制 Linux采用了写时复制的方法，以减少fork时对父进程空间进程整体复制带来的开销。 写时复制是一种采取了惰性优化方法来避免复制时的系统开销。它的前提很简单：如果有多个进程要读取它们自己的那部门资源的副本，那么复制是不必要的。每个进程只要保存一个指向这个资源的指针就可以了。只要没有进程要去修改自己的“副本”，就存在着这样的幻觉：每个进程好像独占那个资源。从而就避免了复制带来的负担。如果一个进程要修改自己的那份资源“副本”，那么就会复制那份资源，并把复制的那份提供给进程。不过其中的复制对进程来说是透明的。这个进程就可以修改复制后的资源了，同时其他的进程仍然共享那份没有修改过的资源。所以这就是名称的由来：在写入时进行复制。 写时复制的主要好处在于：如果进程从来就不需要修改资源，则不需要进行复制。惰性算法的好处就在于它们尽量推迟代价高昂的操作，直到必要的时刻才会去执行。 在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork( )调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。 写时复制在内核中的实现非常简单。与内核页相关的数据结构可以被标记为只读和写时复制。如果有进程试图修改一个页，就会产生一个缺页中断。内核处理缺页中断的方式就是对该页进行一次透明复制。这时会清除页面的COW属性，表示着它不再被共享。 现代的计算机系统结构中都在内存管理单元（MMU）提供了硬件级别的写时复制支持，所以实现是很容易的。 在调用fork( )时，写时复制是有很大优势的。因为大量的fork之后都会跟着执行exec，那么复制整个父进程地址空间中的内容到子进程的地址空间完全是在浪费时间：如果子进程立刻执行一个新的二进制可执行文件的映像，它先前的地址空间就会被交换出去。写时复制可以对这种情况进行优化。 fork和vfork的区别： fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。 4.当需要改变共享数据段中变量的值，则拷贝父进程。","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"},{"name":"面试","slug":"面试","permalink":"https://blog.xtcgch.ink/tags/面试/"},{"name":"C","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"jenkins的配置和使用","slug":"20200819-jenkins的配置和使用","date":"2020-08-19T09:58:39.000Z","updated":"2020-11-04T07:19:45.100Z","comments":true,"path":"jenkins/","link":"","permalink":"https://blog.xtcgch.ink/jenkins/","excerpt":"摘要：本文记录一下jenkins的配置和使用。","text":"摘要：本文记录一下jenkins的配置和使用。 先占个坑 脑图 简介 配置","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"jenkins","slug":"jenkins","permalink":"https://blog.xtcgch.ink/tags/jenkins/"},{"name":"运维","slug":"运维","permalink":"https://blog.xtcgch.ink/tags/运维/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"ubuntu设置静态IP地址","slug":"20200819-ubuntu设置静态IP地址","date":"2020-08-19T08:02:06.000Z","updated":"2020-11-04T07:20:52.133Z","comments":true,"path":"ubuntu设置静态IP地址/","link":"","permalink":"https://blog.xtcgch.ink/ubuntu设置静态IP地址/","excerpt":"摘要：本文记录了ubuntu18.04和20.04版本设置静态IP的方法。","text":"摘要：本文记录了ubuntu18.04和20.04版本设置静态IP的方法。 脑图yaml那么简单，应该不需要脑图!? 前言 不同配置文本的格式都不尽相同，都是坑，希望早日能够财务自由！珍爱生命，远离编程！ ubuntu18.04 和 ubuntu20.04两个版本的配置方法是一样的!ubuntu18.04 和 ubuntu20.04两个版本的配置方法是一样的!ubuntu18.04 和 ubuntu20.04两个版本的配置方法是一样的! 配置方法 备份原始配置文件 1sudo cp /etc/netplan/01-network-manager-all.yaml /etc/netplan/01-network-manager-all.yaml.bak 原始配置文件内容 1234# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: NetworkManager 新配置文件内容 1234567891011# Let NetworkManager manage all devices on this systemnetwork: version: 2 renderer: NetworkManager ethernets: enp0s8: dhcp4: no addresses: [192.168.1.112/24] gateway4: 192.168.1.1 nameservers: addresses: [8.8.8.8,114.114.114.114] 注意： yaml文件的格式：冒号”:”后必须有个空格(欸，这就是猿们喜欢自己造轮子的原因) 应用配置 1sudo netplan apply yaml语法To be continue","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.xtcgch.ink/tags/ubuntu/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"shell学习","slug":"20200811-shell学习","date":"2020-08-11T06:19:37.000Z","updated":"2020-11-04T07:21:08.065Z","comments":true,"path":"shell学习/","link":"","permalink":"https://blog.xtcgch.ink/shell学习/","excerpt":"摘要：记录shell的学习过程！","text":"摘要：记录shell的学习过程！ 脑图 简述 语法查找替换源文件内容替换1sed -i &apos;s/abcd/efghk/g&apos; data.txt 截取1awk -F&apos;|&apos; &apos;&#123;&#125;BEGIN&#123;&#125;END&#123;&#125;&apos; data.txt 常用功能后台执行python12nohup sh shell.sh &gt; temp_log.txt 2&gt;&amp;1 &amp;(nohup sh shell.sh ) 统计文本中某一列的和文本：data.txt123banana 1.5apple 6.0peach 3.2 脚本：1cat data.txt|awk -F&apos; &apos; -v sum=0 &apos;&#123;sum += $2&#125; END&#123;print sum&#125;&apos; 输出：110.7 统计某列值得类型文本：123452020-08-11 5002020-08-09 62020-08-10 152020-08-11 292020-08-12 6 脚本：1awk &apos;&#123;count[$1]++;count2[$2]++&#125;END&#123;print length(count),length(count2)&#125;&apos; data.txt 输出：14 4 多文本处理文本：a.txt123banana 1.5apple 6.0peach 3.2 b.txt1234banana 1.5car 20000house 5000000horse 2000 脚本：1awk -F&apos;|&apos; &apos;ARGIND==1&#123;data[$1]=0;&#125;ARGIND==2&#123;if($1 in data)&#123;printf(&quot;%s|%s\\n&quot;,$1,$2);&#125;&#125;END&#123;&#125;&apos; a.txt b.txt 输出：1banana 1.5 批量发送http请求1awk &apos;&#123; system( &quot;curl -d \\&quot;data=&quot; $0 &quot;\\&quot; http://127.0.0.1/cgi-bin/cgi.cgi&quot; ) &#125;&apos; files.txt 应用场景 总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.xtcgch.ink/tags/shell/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"go学习","slug":"20200127-go学习","date":"2020-01-27T15:58:12.000Z","updated":"2020-11-04T07:21:34.892Z","comments":true,"path":"go学习/","link":"","permalink":"https://blog.xtcgch.ink/go学习/","excerpt":"摘要：这是摘要！","text":"摘要：这是摘要！ 脑图 其他模板的标题 环境配置下载下载地址 环境配置解压缩和复制二进制文件到/usr/local,并且配置环境变量12tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gzsource /etc/profile 测试查看版本1go version 输出1go version go1.14.7 linux/amd64 测试脚本1234567package mainimport &quot;fmt&quot;func main() &#123; fmt.Printf(&quot;hello, world\\n&quot;)&#125; 输出：1hello, world gin框架下载下载地址 安装1go get -u github.com/gin-gonic/gin 安装1import &quot;github.com/gin-gonic/gin&quot; 总结无","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"go","slug":"go","permalink":"https://blog.xtcgch.ink/tags/go/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"python学习","slug":"20200127-python学习","date":"2020-01-27T15:47:02.000Z","updated":"2020-11-22T02:23:16.695Z","comments":true,"path":"python学习/","link":"","permalink":"https://blog.xtcgch.ink/python学习/","excerpt":"摘要：记录python的学习过程！","text":"摘要：记录python的学习过程！ 脑图 1、定义引用的python处理器1#!/usr/bin/python 2、引用包和模块12345678import sysimport commandsimport MySQLdbimport csvimport datetimeimport timeimport os 3、定义函数12345def get_refund_bills_with_mid(nums): data= 12345 + nums return numsretval = get_refund_bills_with_mid(5) 4、输出 屏幕输出 1print (&quot;%s , %d&quot;%(str,intval)) 文件输出 123fo = open(&quot;text.txt&quot;,&quot;w&quot;)fo.write(&quot;%s , %d&quot;%(str,intval))fo.close() 5、MYSQL数据库连接 引入mysql模块 链接mysql数据库 1234posbill_read = MySQLdb.connect(host=&quot;&quot;,user = &quot;&quot;,passwd = &quot;&quot;,use_unicode=True,charset=&apos;utf8&apos;)cursor_read = posbill_read.cursor()cursor_read.close()posbill_read.close() 事务的提交和回滚 12posbill_read.commit()posbill_read.rollback() 获取数据 1234results = cursor_read.execute(sql)for one in results: data0 = one[0] data1 = one[1] 6、设置全局编码123import sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;) # 设置默认编码格式为&apos;utf-8&apos; 7、map的使用 定义 1map_data = &#123;&#125; 赋值 1234if key not in map_data: map_data[key] = valueelse: map_data[key] = value2 遍历 123for key in map_data.keys(): print key print map_data[key] 8、读取配置文件 引用包 1import ConfigParser 载配置文件 12cf = ConfigParser.ConfigParser()cf.read(&quot;/home/data/config.properties&quot;) 读取配置节点 12ip= cf.get(&quot;node1&quot;, &quot;IP&quot;)port = cf.get(&quot;node1&quot;, &quot;PORT&quot;) 配置文件 123[node1]IP = 127.0.0.1PORT = 3306 9、IF语句 多条件判断123456if key1 ==1 and key2 != 2: print &quot;if 1&quot;elif key1 !=2 or key2 ==2 : print &quot;if 2&quot;else: print &quot;if 3&quot; 10、网络编程 服务器端 1234567891011121314#!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名：server.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象 host = socket.gethostname() # 获取本地主机名 port = 12345 # 设置端口 s.bind((host, port)) # 绑定端口 s.listen(5) # 等待客户端连接 while True: c,addr = s.accept() # 建立客户端连接 print &apos;连接地址：&apos;, addr c.send(&apos;欢迎访问菜鸟教程！&apos;) c.close() # 关闭连接 客户端 12345678910#!/usr/bin/python # -*- coding: UTF-8 -*- # 文件名：client.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象 host = socket.gethostname() # 获取本地主机名 port = 12345 # 设置端口号 s.connect((host, port)) print s.recv(1024) s.close() 11、多线程 函数式：调用thread模块中的start_new_thread()函数来产生新线程。 12345678910111213141516171819#!/usr/bin/python # -*- coding: UTF-8 -*- import thread import time #为线程定义一个函数 def print_time( threadName, delay): count = 0 while count &lt; 5: time.sleep(delay) count += 1 print &quot;%s: %s&quot; % ( threadName, time.ctime(time.time()) ) # 创建两个线程 try: thread.start_new_thread( print_time, (&quot;Thread-1&quot;, 2, ) ) thread.start_new_thread( print_time, (&quot;Thread-2&quot;, 4, ) ) except: print &quot;Error: unable to start thread&quot; while 1: pass 使用Threading模块创建线程使用Threading模块创建线程，直接从threading.Thread继承，然后重写init方法和run方法： 12345678910111213141516171819202122232425262728293031#!/usr/bin/python # -*- coding: UTF-8 -*- import threading import time exitFlag = 0 class myThread (threading.Thread): #继承父类threading.Thread def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): #把要执行的代码写到run函数里面 线程在创建后会直接运行run函数 print &quot;Starting &quot; + self.name print_time(self.name, self.counter, 5) print &quot;Exiting &quot; + self.name def print_time(threadName, delay, counter): while counter: if exitFlag: (threading.Thread).exit() time.sleep(delay) print &quot;%s: %s&quot; % (threadName, time.ctime(time.time())) counter -= 1 # 创建新线程 thread1 = myThread(1, &quot;Thread-1&quot;, 1) thread2 = myThread(2, &quot;Thread-2&quot;, 2) # 开启线程 thread1.start() thread2.start() print &quot;Exiting Main Thread&quot; 线程同步 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python # -*- coding: UTF-8 -*- import threading import time class myThread (threading.Thread): def __init__(self, threadID, name, counter): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.counter = counter def run(self): print &quot;Starting &quot; + self.name # 获得锁，成功获得锁定后返回True # 可选的timeout参数不填时将一直阻塞直到获得锁定 # 否则超时后将返回False hreadLock.acquire() print_time(self.name, self.counter, 3) # 释放锁 threadLock.release() def print_time(threadName, delay, counter): while counter: time.sleep(delay) print &quot;%s: %s&quot; % (threadName, time.ctime(time.time())) counter -= 1 hreadLock = threading.Lock() threads = [] # 创建新线程 thread1 = myThread(1, &quot;Thread-1&quot;, 1) thread2 = myThread(2, &quot;Thread-2&quot;, 2) # 开启新线程 thread1.start() thread2.start() # 添加线程到线程列表 threads.append(thread1) threads.append(thread2) # 等待所有线程完成 for t in threads: t.join() print &quot;Exiting Main Thread&quot; 线程优先队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/python # -*- coding: UTF-8 -*- import Queue import threading import time exitFlag = 0 class myThread (threading.Thread): def __init__(self, threadID, name, q): threading.Thread.__init__(self) self.threadID = threadID self.name = name self.q = q def run(self): print &quot;Starting &quot; + self.name process_data(self.name, self.q) print &quot;Exiting &quot; + self.name def process_data(threadName, q): while not exitFlag: queueLock.acquire() if not workQueue.empty(): data = q.get() queueLock.release() print &quot;%s processing %s&quot; % (threadName, data) else: queueLock.release() time.sleep(1) threadList = [&quot;Thread-1&quot;, &quot;Thread-2&quot;, &quot;Thread-3&quot;] nameList = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;] queueLock = threading.Lock() workQueue = Queue.Queue(10) threads = [] threadID = 1 # 创建新线程 for tName in threadList: thread = myThread(threadID, tName, workQueue) thread.start() threads.append(thread) threadID += 1 # 填充队列 queueLock.acquire() for word in nameList: workQueue.put(word) queueLock.release() # 等待队列清空 while not workQueue.empty(): pass # 通知线程是时候退出 exitFlag = 1 # 等待所有线程完成 for t in threads: t.join() print &quot;Exiting Main Thread&quot; 12、json json函数 12345678910import json函数描述json.dumps将 Python 对象编码成 JSON 字符串json.loads将已编码的 JSON 字符串解码为 Python 对象 json.dumps 123456789#!/usr/bin/pythonimport jsondata = [ &#123; &apos;a&apos; : 1, &apos;b&apos; : 2, &apos;c&apos; : 3, &apos;d&apos; : 4, &apos;e&apos; : 5 &#125; ]json = json.dumps(data)print json json.loads 123456789#!/usr/bin/pythonimport jsonjsonData = &#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3,&quot;d&quot;:4,&quot;e&quot;:5&#125;;text = json.loads(jsonData)print text 13、操作excel 引入openpyxl模块 1import openpyxl 加载excel 123path = &apos;/home/lucas/test/python_excel/test.xlsx&apos;# 加载工作本workbook = openpyxl.load_workbook(path) 获取工作表 1sheet = workbook[&apos;Sheet1&apos;] 获取单元格的值 根据row和col的索引来遍历 123456data=&#123;&#125;for x in range(1,8): for y in range(1,3): cell = sheet.cell(row=x, column=y) if y != 1: data[x] = cell.value 根据起始单元格遍历 12345cells = sheet[&apos;A1&apos;:&apos;C1&apos;]for row in cells: for col in row: # 获取属性值 print(col.value) 写入和保存excel 12345678910# -*- coding: utf-8 -*-import openpyxlpath = &apos;/home/lucas/test/python_excel/test.xlsx&apos;wb = openpyxl.Workbook()# 创建一个 sheetsheet = wb.create_sheet(&apos;sheet1&apos;)# 写入文本形式sheet[&apos;A1&apos;] = &apos;12345&apos;wb.save(path) 总结无","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.xtcgch.ink/tags/python/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"SQL优化","slug":"20200127-SQL优化","date":"2020-01-27T12:55:14.000Z","updated":"2020-01-28T03:16:30.960Z","comments":true,"path":"SQL优化/","link":"","permalink":"https://blog.xtcgch.ink/SQL优化/","excerpt":"摘要：SQL语句作为数据库和程序的交互语言，优秀的sql语句是理所当然的，但是很多人却不是很重视SQL语句，本文就是针对SQL的病句进行问题剖析，然后给出优化方案，以此来端正对SQL语句的态度。","text":"摘要：SQL语句作为数据库和程序的交互语言，优秀的sql语句是理所当然的，但是很多人却不是很重视SQL语句，本文就是针对SQL的病句进行问题剖析，然后给出优化方案，以此来端正对SQL语句的态度。 脑图暂无 一、常见案例1. 查询列发生隐式或显示的类型转换(1)描述 where 条件中的字符串没有使用引号 1不用引号的条件不会使用索引 (2)优化建议 查询列是什么字段类型，列的值就应该用什么字段类型，否则会导致发生类型转换而使用不到索引 对有索引的查询列不要使用函数或运算的操作，例如to_char(列)，列%10，列+10等 2. 对于查询频繁的列，并且列的选择性比较高，应当建立索引(1)描述 无 (2)优化建议 查询列建立索引 建索引原则，这个列的无重复值的数量和表的记录数越接近，说明选择性好，建的索引查询就越高效，比如主键，时间，身份证，手机号等 的重复值很高，根据值的分布，某个值的重复值却很少，而查询只查询这个值，这时候该字段就适合创建索引 3. 存在索引，实际执行的时候并未使用到(1)描述 如问题1 对于组合索引，where中并未按顺序进行查询 单表多条件查询时使用or，或者联表查询时的不合理使用 (2)优化建议 虽然查询的字段有索引，但是查询范围过大，导致使用不到索引，应该将范围拆分为更小的几段，然后再进行汇总 or条件改为in,否则用不到索引 模糊查询时，尽量使用后置%，否则使用不到索引 4. 表关联的字段需要有索引，尽量少用子查询(1)描述 (2)优化建议 关联的字段创建索引，并且将子查询改为表关联 另一个字段F_remark虽然重复值比较多，但是这个值的数量却很少，建索引对该查询有效 5. 索引字段进行模糊查询时，like ‘%%’会导致使用不到索引(1)描述 无 (2)优化建议 将模糊查询like %xxx% 语句改为 xxx% 6. 存在多个索引时，mysql错误的选择了索引(1)描述 (2)优化建议 改写原查询sql，加上force index(idx_agent_id) 强制使用F_agent_id索引 一般不推荐使用force index固定执行计划，因为数据是变化的，数据库内部会收集各种统计信息给出最优的执行计划，但是5.1版本做的不够好，在5.7版本得到了增强 7. 对于联合索引来说，要遵守最左前缀法则(1)描述 (2)优化建议 对于 index(a,b,c)复合索引，根据最左前缀规则，a,(a,b),(a,b,c)都可以使用到索引，而(b,c)不能使用到 为使用到索引，加上f_status条件，并将该列的所有值查出来 8.SQL语句中IN包含的值不应过多二、常见案例 单表查询时：联合索引中范围之后的索引将 会失效 单表查询时：联合索引中范围之后的索引将 会失效 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：select id from t where num=0 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描 in 和 not in 也要慎用，否则会导致全表扫描，如：select id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：select id from t where num between 1 and 3 很多时候用 exists 代替 in 是一个好的选择：select num from a where num in(select num from b)用下面的语句替换：select num from a where exists(select 1 from b where num=a.num) 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效 尽量避免大事务操作，提高系统并发能力 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理 三、总结暂无","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.xtcgch.ink/tags/数据库/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.xtcgch.ink/tags/SQL/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"技术相关经典书籍","slug":"20190407-技术相关经典书籍","date":"2019-04-07T08:01:39.000Z","updated":"2020-11-04T07:22:27.781Z","comments":true,"path":"技术相关经典书籍/","link":"","permalink":"https://blog.xtcgch.ink/技术相关经典书籍/","excerpt":"摘要：本页主要列举了技术类相关的经典书籍，闲暇时间可以多看看！","text":"摘要：本页主要列举了技术类相关的经典书籍，闲暇时间可以多看看！ 编程语言类 go python shell lua 编程思维类 编程珠玑 计算机编程艺术(一、二、三卷) Effective C++ Thinking in C++ C++编程艺术 C++编程思想(一、二卷) C++编程规范 C++代码设计与重用 计算机网络类 UNIX网络编程 C++网络编程 TCP/IP 高级TCP/IP编程 linux网络体系结构 TCP/IP高效编程 TCP/IP协议原理与应用 用TCP/IP进行网际互连 IPv6详解 操作系统类 UNIX环境高级编程 Linux内核设计与实现 深入理解Linux内核 数据库类其他类","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"leetcode的经典题目","slug":"20190407-leetcode的经典题目","date":"2019-04-07T07:51:08.000Z","updated":"2020-11-22T02:23:24.448Z","comments":true,"path":"leetcode的经典题目/","link":"","permalink":"https://blog.xtcgch.ink/leetcode的经典题目/","excerpt":"摘要：本页主要摘录leetcode上面一些经典的题目！","text":"摘要：本页主要摘录leetcode上面一些经典的题目！ 基础知识类编程语言类网络相关数据库相关操作系统相关扩展点一扩展点二算法类","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://blog.xtcgch.ink/tags/leetcode/"},{"name":"面试","slug":"面试","permalink":"https://blog.xtcgch.ink/tags/面试/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"画流程图","slug":"20190407-画流程图","date":"2019-04-07T04:30:06.000Z","updated":"2020-11-04T07:23:18.520Z","comments":true,"path":"画流程图/","link":"","permalink":"https://blog.xtcgch.ink/画流程图/","excerpt":"摘要：介绍流程图的一些知识！","text":"摘要：介绍流程图的一些知识！ 先从软件工程开始–&gt; 参考文档 目录 为何需要软件工程 过程模块与生命周期 项目计划与管理 需求分析 系统设计 关于对象 编写代码 程序测试 系统测试 系统提交 系统维护 产品，过程，资源评估 预测，处理和资源的改进 软件工程的前景","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://blog.xtcgch.ink/tags/软件工程/"},{"name":"流程图","slug":"流程图","permalink":"https://blog.xtcgch.ink/tags/流程图/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"协程的介绍","slug":"20190405-协程的介绍","date":"2019-04-05T12:27:04.000Z","updated":"2019-04-05T15:04:15.172Z","comments":true,"path":"协程的介绍/","link":"","permalink":"https://blog.xtcgch.ink/协程的介绍/","excerpt":"摘要：非正式的协程学习笔记！","text":"摘要：非正式的协程学习笔记！ 简单介绍协程，又称微线程，纤程。英文名Coroutine。 协程属于线程内的概念，脱离了线程就毫无意义。 一个线程可以有很多个协程，协程数受到文件描述符的限制。 协程是原子性的。 协程的切换属于用户态，即只有显示使用协程，cpu才会使用协程的方式来处理代码。 一个线程里的协程共享所有线程内的变量，且是独享，即每个协程获取到的线程变量值都是即时的数据，和线程使用进程内的公共变量不同，也即不需要加锁。 协程的切换是由IO事件来操控，只有当协程发生IO操作，或者协程处理完事件，才会发生协程的切换。 协程占有的资源量比线程小，且通常情况下协程间的切换对资源的消耗是比较小的，主要是因为协程切换时不会发生上下文的切换，cpu会根据偏移量来找到协程对应的栈位置，所以协程间的切换只是偏移量发生了改变，因此对资源的消耗量很小。 和线程比，在IO任务不处理具体事情时，线程会被挂起，但是协程会一直切换，会消耗一定的cpu资源，目前可测出的消耗率约为1%-2%。 语言层面目前支持协程的编程语言主要有python，lua，C/C++ 应用场景协程的特性是由IO事件来进行切换，因此在一些IO事件比较频繁的场景下运用，能够产生比较巨大的正面效果，如http/https请求，udp/tcp请求，数据库IO，文件IO，日志IO 一些协程库 libco 坑1、锁在一个函数fun1()中有一个IO操作，如写日志（设定为一直阻塞），并且在写日志前进行加锁，这时可能会发生如下情况： 协程A获取锁，进行写日志IO操作 cpu切换协程B来运行 协程B视图获取锁，但是协程A未释放，因此协程B一直等待 由于协程A一直阻塞在写日志操作，因此协程B也一直阻塞，也不能被切换出去，造成了死锁 即使协程A未被阻塞，而是耗时比较长，那么协程B也只能等待，这种情况也会比较坑 2、socket 一些使用建议 在使用IO函数之前要先释放锁 使用最小粒度的锁","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"协程","slug":"协程","permalink":"https://blog.xtcgch.ink/tags/协程/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"使用hexo搭建github博客","slug":"20190402-使用hexo搭建github博客","date":"2019-03-31T09:24:36.000Z","updated":"2019-04-05T15:00:50.700Z","comments":true,"path":"使用hexo搭建github博客/","link":"","permalink":"https://blog.xtcgch.ink/使用hexo搭建github博客/","excerpt":"摘要：主要介绍利用hexo搭建个人的github博客！","text":"摘要：主要介绍利用hexo搭建个人的github博客！ 总体思路介绍1、创建和配置github仓库 这一步主要有2个作用 存放博客相关文件 能够建立本地git仓库和远程github仓库的连接，便于远程管理。这个功能还需要配置本地git和其他依赖环境 2、配置本地环境 这一步主要是配置git工具和hexo博客的环境 配置git和依赖的工具，主要是nodejs 搭建hexo博客环境 3、配置博客主题 hexo支持很多博客主题，这些主题可以从github上面去clone和update，对于假装很喜欢写博客的我来说，用得爽才是最好的 4、进行一些个性化的改造 就像对待自己女朋友一样，要把她变成私有的，烙上自己独特的印记，最常用的有配置域名啦，对主题进行配置啦，模板配置啦，一键部署啦，等等 各个步骤说明创建github仓库1、创建一个public的repos 2、设置启用https 部署本地环境1、安装git git可以把本地的博客文件commit到远程仓库，即对博客进行更新 2、创建ssh的rsa公钥和密钥，配置连接远程仓库的参数 本地git和远程仓库进行连接时，首先需要进行安全验证，目前使用ssh的rsa key来保证，远程仓库使用public key，本地使用private key 其次需要配置连接到哪个用户，哪个仓库，这就需要显示地指定目标地址 一般有2中配置方式：直接配置用户环境、配置文件信息 其中配置用户环境比较简单，但是可配置性也比较差 配置文件信息稍微复杂点，但是可配置性比较高，适合个性化配置，见后面说明 3、安装nodejs nodejs是管理hexo博客的主要工具，主要用到nodejs里面的npm，nodejs支持把markdown文件转为静态网页 同时npm也可以安装一些主题需要的模块 配置博客主题hexo的默认主题是landscape，我用的是snippet 在根目录的_config.yml文件里面可以指定要使用的主题，然后在generate阶段会去themes目录下寻找对应的主题 配置博客主题主要有2方面： 在根目录的配置文件中指定主题 在主题目录里面进行个性化配置 第二点的坑比较多，在配置snippet时，我遇到的坑有： 要安装ejs 模版引擎 、 Less CSS预编译语言，安装项目的依赖 要对根目录的_config.yml结构进行更改，还要拷贝package.json到根目录等等 修改url地址，这点无疑是最坑的，无论修改成github仓库地址还是域名 配置域名1、阿里云/腾讯/万网进行解析，添加CNAME记录即可 2、github仓库设置好域名，添加CNAME文件 常见问题1、hexo d 时出现错误 Error: ERROR: Permission to 原因：登录账号和push到仓库的账号不一致，要么配置错误，要么是存在多账号的问题 解决方法：使用配置文件的方式来进行登录和push 2、hexo d后 ERROR Deployer not found: git 原因：未指定hexo的发布工具 解决方法:1npm install --save hexo-deployer-git 具体步骤参考文章： 综合配置 snippet主题 账号的配置 1、创建和配置仓库略 2、安装和配置git安装：略 创建SSH KEY 12cd ~/.ssh/ssh-keygen -t rsa -f ~/.ssh/abc_rsa -C &quot;yourmail@xxx.com&quot; //abc为自定义名，常用github登录名 配置git连接到github仓库 配置文件 - 配置多个账号时要根据邮箱创建不同的SSH KEY1234567cd ~/.ssh/touch config# 账号名 abcHost abc.github.com # abc为github的登录账号名 HostName github.com User git IdentityFile ~/.ssh/abc_rsa 原理分析: ssh 客户端是通过类似 git@abc.github.com:abc/blog.git 的地址来识别使用本地的哪个私钥的，(abc是github登录名，blog是仓库名) 如果所有账号的 User 和 Host 都为 git 和 github.com，那么就只能使用一个私钥。所以要对User 和 Host 进行配置，让每个账号使用自己的 Host，每个 Host 的域名做 CNAME 解析到 github.com，如上面配置中的Host abc.github.com。 配置了别名之后，新的地址就是git@abc.github.com:abc/blog.git。这样 ssh 在连接时就可以区别不同的账号了。 github仓库添加SSH KEY 打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： title： 内容：填abc_rsa.pub里面的公钥 在.ssh根目录下, 清空本地的 SSH 缓存，添加新的 SSH 密钥 到 SSH agent中 添加： 123cd ~/.sshssh-add -Dssh-add abc_rsa 验证新秘钥已经添加成功： 1ssh-add -l 使用环境变量配置时，输入指令, 验证配置是否成功: 1ssh -T git@github.com 使用配置文件时，输入指令, 验证配置是否成功: 1ssh -T git@abc.github.com 进入各自项目文件夹，单独设置用户名/邮箱 注意：如果有多个账号，建议使用局部的。 1234567# 取消全局 用户名/邮箱 配置git config –global –unset user.namegit config –global –unset user.email# 单独设置每个repo 用户名/邮箱git config user.name &quot;用户名&quot; //在config后加上--global即全局git config user.email &quot;邮箱&quot; 查看设置是否成功 1git config --list 在 hexo 配置文件_config.yml修改git地址 1234deploy: type: git repository: git@abc.github.com:abc/blog.github.io.git branch: master 3、安装和配置git 前提条件：安装nodejs 配置淘宝镜像：pm install -g cnpm –registry=https://registry.npm.taobao.org 安装:npm install -g hexo-cli 查看：hexo -version 初始化hexo框架 进入文件夹：hexo init 启动Hexo服务：hexo s 查看效果：localhost:4000 设置bat快捷命令文件 新建：123456@echo offecho Wait a minute ...D: &amp;&amp; cd D:\\github_workplace\\blog &amp;&amp; hexo n newecho Finished !start D:\\github_workplace\\blog\\source\\_postspause 发布：12345@echo offecho Wait a minute ...D: &amp;&amp; cd D:\\github_workplace\\blog &amp;&amp; hexo clean &amp;&amp; hexo g &amp;&amp; hexo decho Finished !pause 4、域名 在本地根目录的source文件夹下创建CNAME文件，输入域名，如：blog.abc.com github仓库的setting/GitHub Pages/Custom domain一栏输入域名 在阿里云/腾讯/万网添加域名解析记录CNAME，主机记录为blog，记录值是abc.github.io 温馨提示：配置域名后，几乎可以立即使用http的方式进行访问，但如果要启用https，则可以泡一杯咖啡，耐心等待5分钟，等待https证书的传输等过程完成，然后就可以进行访问了 snippet主题设置唉，坑 扩展：个性化的设置1、迁移到另一台电脑或重装系统后的配置","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.xtcgch.ink/tags/hexo/"},{"name":"github","slug":"github","permalink":"https://blog.xtcgch.ink/tags/github/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"Linux下的一些小知识","slug":"20190319-Linux下的一些小知识","date":"2019-03-19T15:54:45.000Z","updated":"2020-11-22T16:03:23.263Z","comments":true,"path":"Linux下的一些小知识/","link":"","permalink":"https://blog.xtcgch.ink/Linux下的一些小知识/","excerpt":"摘要：专治各种水土不服","text":"摘要：专治各种水土不服 linu系统介绍1、内核 2、Linux文件结构 /bin：bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。 /boot：这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。 /dev ：dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。 /etc：etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。 /home：用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。 /lib：lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /media：linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。 /opt：opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。 /proc：proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，使别人无法ping你的机器： /root：该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin：s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。 /selinux： 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。 /srv： 该目录存放一些服务启动之后需要提取的数据。 /sys：这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。 sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。 /tmp： tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的。 /usr： usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。 /usr/src：内核源代码默认的放置目录。 /var：var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。 文件编码问题在windows系统中生成的文件，在Linux系统中会出现各种格式方面的问题，比如cpp文件的编译错误 查看文件编码格式：set fileencoding设置文件编码格式：set fileencoding = utf8","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.xtcgch.ink/tags/Linux/"},{"name":"centos","slug":"centos","permalink":"https://blog.xtcgch.ink/tags/centos/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"python的使用","slug":"20190319-python的使用","date":"2019-03-19T14:41:56.000Z","updated":"2020-11-04T07:21:51.713Z","comments":true,"path":"python的使用/","link":"","permalink":"https://blog.xtcgch.ink/python的使用/","excerpt":"摘要：非正规的python心得。","text":"摘要：非正规的python心得。 python文件的定义1#!/usr/bin/python 行和缩进 Python 的代码块不使用大括号 {} 来控制类，函数以及其他逻辑判断 python 最具特色的就是用缩进来写模块 缩进的空白数量是可变的，但是所有代码块语句必须包含相同的缩进空白数量，这个必须严格执行 1234if True: print &quot;True&quot;else: print &quot;False&quot; Python 标识符 Python 中的标识符是区分大小写的 以下划线开头的标识符是有特殊意义的 以单下划线开头 _foo 的代表不能直接访问的类属性,需通过类提供的接口进行访问 以双下划线开头的 __foo 代表类的私有成员 以双下划线开头和结尾的 foo 代表 Python 里特殊方法专用的标识 Python 可以同一行显示多条语句，方法是用分号 ; 分开1print &apos;hello&apos;;print &apos;runoob&apos;; 多行语句 Python语句中一般以新行作为语句的结束符 可以使用斜杠（ \\）将一行的语句分为多行显示 123total = item_one + \\ item_two + \\ item_three 语句中包含 [], {} 或 () 括号就不需要使用多行连接符 12days = [&apos;Monday&apos;, &apos;Tuesday&apos;, &apos;Wednesday&apos;, &apos;Thursday&apos;, &apos;Friday&apos;] Python 引号 Python 可以使用引号( ‘ )、双引号( “ )、三引号( ‘’’ 或 “”” ) 来表示字符串 三引号(“””)可以由多行组成，编写多行文本的快捷语法，常用于文档字符串，在文件的特定地点，被当做注释 1234word = &apos;word&apos;sentence = &quot;这是一个句子。&quot;paragraph = &quot;&quot;&quot;这是一个段落。包含了多个语句&quot;&quot;&quot; Python注释 单行注释：# 注意：第一行的#! /bin/bash不是表示注释，而是指明了执行该脚本的bash解释器的位置 python 中多行注释使用三个单引号(‘’’)或三个双引号(“””) 1234567891011&apos;&apos;&apos;这是多行注释，使用单引号。这是多行注释，使用单引号。这是多行注释，使用单引号。&apos;&apos;&apos;&quot;&quot;&quot;这是多行注释，使用双引号。这是多行注释，使用双引号。这是多行注释，使用双引号。&quot;&quot;&quot; 空行 函数之间或类的方法之间用空行分隔，表示一段新的代码的开始 空行的作用在于分隔两段不同功能或含义的代码，便于日后代码的维护或重构 空行也是程序代码的一部分 同一行显示多条语句Python可以在同一行中使用多条语句，语句之间使用分号(;)分割 123#!/usr/bin/pythonimport sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\\n&apos;) Print 输出print 默认输出是换行的，如果要实现不换行需要在变量末尾加上逗号 , 12345678910111213141516#!/usr/bin/python# -*- coding: UTF-8 -*-x=&quot;a&quot;y=&quot;b&quot;# 换行输出print xprint yprint &apos;---------&apos;# 不换行输出print x,print y,# 不换行输出print x,y if else语句while语句常用运算布尔运算字符串运算关系运算算术运算mysql数据库操作文件io获取命令行参数获取参数个数1count = sys.argc 获取某个参数1param = sys.argv[1]","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"python","slug":"python","permalink":"https://blog.xtcgch.ink/tags/python/"},{"name":"脚本","slug":"脚本","permalink":"https://blog.xtcgch.ink/tags/脚本/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"Nginx中FastCGI的解读","slug":"20190309-Nginx中FastCGI的解读","date":"2019-03-09T15:19:37.000Z","updated":"2020-11-22T02:41:37.669Z","comments":true,"path":"Ngix中FastCGI的解读/","link":"","permalink":"https://blog.xtcgch.ink/Ngix中FastCGI的解读/","excerpt":"摘要：本文主要是阅读ngix中fastcgi的源码来了解c++对http请求体的解析，以及对回复包的封装过程。","text":"摘要：本文主要是阅读ngix中fastcgi的源码来了解c++对http请求体的解析，以及对回复包的封装过程。 1.初识FastCGI协议 1.1消息头 FastCGI定义了多种类型的消息；nginx对FastCGI消息类型定义如下： 12345678#define NGX_HTTP_FASTCGI_BEGIN_REQUEST 1#define NGX_HTTP_FASTCGI_ABORT_REQUEST 2#define NGX_HTTP_FASTCGI_END_REQUEST 3#define NGX_HTTP_FASTCGI_PARAMS 4#define NGX_HTTP_FASTCGI_STDIN 5#define NGX_HTTP_FASTCGI_STDOUT 6#define NGX_HTTP_FASTCGI_STDERR 7#define NGX_HTTP_FASTCGI_DATA 8 一般情况下，最先发送的是BEGIN_REQUEST类型的消息，然后是PARAMS和STDIN类型的消息； 当FastCGI响应处理完后，将发送STDOUT和STDERR类型的消息，最后以END_REQUEST表示请求的结束。 FastCGI定义了一个统一结构的8个字节消息头，用来标识每个消息的消息体，以及实现消息数据的分割。结构体定义如下： 12345678910typedef struct &#123; u_char version; //FastCGI协议版本 u_char type; //消息类型 u_char request_id_hi; //请求ID u_char request_id_lo; u_char content_length_hi; //内容 u_char content_length_lo; u_char padding_length; //内容填充长度 u_char reserved; //保留&#125; ngx_http_fastcgi_header_t; 我们看到请求ID与内容长度分别用两个u_char存储，实际结果的计算方法如下：12requestId = (request_id_hi &lt;&lt; 8) + request_id_lo;contentLength = (content_length_hi &lt;&lt; 8) + content_length_lo; 消息体的长度始终是8字节的整数倍，当实际内容长度不足时，需要填充若干字节；填充代码如下所示： 12padding = 8 - len % 8;padding = (padding == 8) ? 0 : padding; 1.2消息体举例 BEGIN_REQUEST类型的消息标识FastCGI请求的开始，结构固定，定义如下：123456typedef struct &#123; u_char role_hi; //标记FastCGI应用应该扮演的角色 u_char role_lo; u_char flags; u_char reserved[5];&#125; ngx_http_fastcgi_begin_request_t; 角色同样使用两个u_char存储，计算方法为：1role = (role_hi &lt;&lt; 8) + role_lo; 最常用的是响应器(Responder)角色，FastCGI应用接收所有与HTTP请求相关的信息，并产生一个HTTP响应。 nginx配置文件中，fastcgi_param指令配置的若干参数，以及HTTP请求的消息头，都是通过FCGI_PARAMS类型的消息传递的，此消息就是若干个名—值对（此名—值对在php中可以通过$_SERVER[ ]获取）； 传输格式为nameLength+valueLength+name+value。 为了节省空间，对于0~127长度的值，Length使用了一个char来表示，第一位为0，对于大于127的长度的值，Length使用了4个char来表示，第一位为1； Length字段编码的逻辑如下：123456789if (val_len &gt; 127) &#123; *b-&gt;last++ = (u_char) (((val_len &gt;&gt; 24) &amp; 0x7f) | 0x80); *b-&gt;last++ = (u_char) ((val_len &gt;&gt; 16) &amp; 0xff); *b-&gt;last++ = (u_char) ((val_len &gt;&gt; 8) &amp; 0xff); *b-&gt;last++ = (u_char) (val_len &amp; 0xff); &#125; else &#123; *b-&gt;last++ = (u_char) val_len;&#125; 2.基础知识 2.1 FastCGI配置 代码中搜索ngx_http_fastcgi_commands，查看fastcgi模块提供的配置指令； 12345678910111213141516static ngx_command_t ngx_http_fastcgi_commands[] = &#123; &#123; ngx_string(&quot;fastcgi_pass&quot;), NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1, //只能出现在location块中 ngx_http_fastcgi_pass, NGX_HTTP_LOC_CONF_OFFSET, 0, NULL &#125;, &#123; ngx_string(&quot;fastcgi_param&quot;), NGX_HTTP_MAIN_CONF|NGX_HTTP_SRV_CONF|NGX_HTTP_LOC_CONF|NGX_CONF_TAKE23, //可以出现在http配置块、server配置块、location配置块中 ngx_http_upstream_param_set_slot, NGX_HTTP_LOC_CONF_OFFSET, offsetof(ngx_http_fastcgi_loc_conf_t, params_source), //ngx_http_fastcgi_loc_conf_t结构的params_source字段是存储配置参数的array， NULL &#125;, …………&#125; fastcgi_pass指令用于配置上游FastCGI应用的ip:port，ngx_http_fastcgi_pass方法解析此指令（设置handler为ngx_http_fastcgi_handler方法，命中当前location规则的HTTP请求，请求处理的内容产生阶段会调用此handler）； fastcgi_param用于配置nginx向FastCGI应用传递的参数，在php中，我们可以通过$_SERVER[&quot; &quot;]获取这些参数； 解析fastcgi_param配置的代码实现如下： 123456789101112131415161718char * ngx_http_upstream_param_set_slot(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)&#123; a = (ngx_array_t **) (p + cmd-&gt;offset); //ngx_http_fastcgi_loc_conf_t结构首地址加params_source字段的偏移 param = ngx_array_push(*a); value = cf-&gt;args-&gt;elts; param-&gt;key = value[1]; param-&gt;value = value[2]; param-&gt;skip_empty = 0; if (cf-&gt;args-&gt;nelts == 4) &#123; //if_not_empty用于配置参数是否必传（如果配置，当值为空时不会传向FastCGI应用传递此参数） if (ngx_strcmp(value[3].data, &quot;if_not_empty&quot;) != 0) &#123; return NGX_CONF_ERROR; &#125; param-&gt;skip_empty = 1; &#125; return NGX_CONF_OK;&#125; 2.2FastCGI配置预处理 fastcgi_param配置的所有参数会会存储在ngx_http_fastcgi_loc_conf_t结构体的params_source字段； nginx为了方便生成fastcgi请求数据，会提前对params_source做一些预处理，预先初始化号每个名—值对的长度以及数据拷贝方法等； 2.1节查看fastcgi模块提供的配置指令时发现，某些配置指令出现在location配置块，有些配置却可以出现http配置块、server配置块和location配置块；即可能出现同一个指令同时出现在好几个配置块中，此时如何解析配置？ 对于这些配置指令，nginx最终会执行一个merge操作，合并多个配置为一个；观察nginx的HTTP模块，大多模块都会存在一个merge_loc_conf字段（函数指针），用于merge配置； fastcgi模块的merge操作由ngx_http_fastcgi_merge_loc_conf完成，其同时对params_source进行了一些预处理；代码如下： 123456789101112131415static char * ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf, void *parent, void *child)&#123; ngx_conf_merge_msec_value(conf-&gt;upstream.connect_timeout, prev-&gt;upstream.connect_timeout, 60000); ngx_conf_merge_value(conf-&gt;upstream.pass_request_headers, prev-&gt;upstream.pass_request_headers, 1); //配置HTTP头部是否传递给FastCGI应用，默认为1 ngx_conf_merge_value(conf-&gt;upstream.pass_request_body, prev-&gt;upstream.pass_request_body, 1); //配置HTTP body是否传递给FastCGI应用，默认为1 ………… if (ngx_http_fastcgi_merge_params(cf, conf, prev) != NGX_OK) &#123; //重点，merger并预处理传递给FastCGI应用的参数 return NGX_CONF_ERROR; &#125;&#125; ngx_http_fastcgi_merge_params方法主要params_source做了一些预处理，主要处理逻辑如下： 注意：配置参数的名称以HTTP_开始时，此参数可能还是HTTP请求头，需要记录这些参数，以便传递HTTP请求头时排除掉。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758static ngx_int_t ngx_http_fastcgi_merge_params(ngx_conf_t *cf, ngx_http_fastcgi_loc_conf_t *conf, ngx_http_fastcgi_loc_conf_t *prev)&#123; if (conf-&gt;params_source) &#123; src = conf-&gt;params_source-&gt;elts; nsrc = conf-&gt;params_source-&gt;nelts; &#125; conf-&gt;params_len = ngx_array_create(cf-&gt;pool, 64, 1); //params_len用于计算参数名—值的长度 conf-&gt;params = ngx_array_create(cf-&gt;pool, 512, 1); //params用于名—值对数据内容的处理（拷贝） if (ngx_array_init(&amp;headers_names, cf-&gt;temp_pool, 4, sizeof(ngx_hash_key_t)) != NGX_OK)&#123; //存储以HTTP_开始的配置参数，hash表 return NGX_ERROR; &#125; for (i = 0; i &lt; nsrc; i++) &#123; //以HTTP_开始，存储在headers_names hash表 if (src[i].key.len &gt; sizeof(&quot;HTTP_&quot;) - 1 &amp;&amp; ngx_strncmp(src[i].key.data, &quot;HTTP_&quot;, sizeof(&quot;HTTP_&quot;) - 1) == 0)&#123; hk = ngx_array_push(&amp;headers_names); hk-&gt;key.len = src[i].key.len - 5; hk-&gt;key.data = src[i].key.data + 5; hk-&gt;key_hash = ngx_hash_key_lc(hk-&gt;key.data, hk-&gt;key.len); hk-&gt;value = (void *) 1; &#125; //ngx_http_script_copy_code_t结构体包含两个字段：code函数指针，用于计算参数名称的长度（方法内部直接返回了了len字段）；len是参数名称的长度 copy = ngx_array_push_n(conf-&gt;params_len, sizeof(ngx_http_script_copy_code_t)); copy-&gt;code = (ngx_http_script_code_pt) ngx_http_script_copy_len_code; copy-&gt;len = src[i].key.len; //这里的len表示参数是否必传；对于非必传参数，当此参数的值为空时，可以不传递此参数；（ngx_http_script_copy_len_code方法内部直接返回了了len字段，即skip_empty） copy = ngx_array_push_n(conf-&gt;params_len, sizeof(ngx_http_script_copy_code_t)); copy-&gt;code = (ngx_http_script_code_pt) ngx_http_script_copy_len_code; copy-&gt;len = src[i].skip_empty; //ngx_http_script_copy_code_t结构体包含两个字段：code函数指针，实现参数名称内容的拷贝；len数参数名称的长度 //空间大小为ngx_http_script_copy_code_t结构体长度，加参数名称的长度；最后再8字节对齐 size = (sizeof(ngx_http_script_copy_code_t) + src[i].key.len + sizeof(uintptr_t) - 1) &amp; ~(sizeof(uintptr_t) - 1); copy = ngx_array_push_n(conf-&gt;params, size); copy-&gt;code = ngx_http_script_copy_code; copy-&gt;len = src[i].key.len; //拷贝数据 p = (u_char *) copy + sizeof(ngx_http_script_copy_code_t); ngx_memcpy(p, src[i].key.data, src[i].key.len); //params_len与params分别存储NULL，以实现存储空间的分隔；及参数与参数之间使用NULL进行隔离； code = ngx_array_push_n(conf-&gt;params_len, sizeof(uintptr_t)); *code = (uintptr_t) NULL; code = ngx_array_push_n(conf-&gt;params, sizeof(uintptr_t)); *code = (uintptr_t) NULL; &#125; conf-&gt;header_params = headers_names.nelts; //以HTTP_开始的参数存储在conf的header_params与headers_hash字段 hash.hash = &amp;conf-&gt;headers_hash; …… return ngx_hash_init(&amp;hash, headers_names.elts, headers_names.nelts); &#125; 根据上面的代码逻辑，很容易画出params_len与params的内部存储结构： 问题：参数是名—值对，这里的代码只对参数名称进行了预处理，参数的值呢？参数的值应该与请求相对应的，在解析配置文件时，并没有请求对应的信息，如何预处理参数的值呢？ 一般fastcgi的参数是以下这些配置：12345fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_param QUERY_STRING $query_string;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param CONTENT_TYPE $content_type;fastcgi_param CONTENT_LENGTH $content_length 参数的值其实就是nginx提供的一系列可以直接使用变量（在ngx_http_variable.c文件中查找ngx_http_core_variables数组，即nginx提供的变量），每个变量都有一个索引值； 预处理fastcgi的配置参数时，其实只需要初始化参数值对应的变量索引即可；（注意参数的值可能是由多个nginx变量组合而成） 注意到ngx_http_fastcgi_merge_params方法中还有以下一段代码： 1234567891011for (i = 0; i &lt; nsrc; i++) &#123; sc.cf = cf; sc.source = &amp;src[i].value; sc.flushes = &amp;conf-&gt;flushes; sc.lengths = &amp;conf-&gt;params_len; sc.values = &amp;conf-&gt;params; if (ngx_http_script_compile(&amp;sc) != NGX_OK) &#123; return NGX_ERROR; &#125;&#125; 我们看到sc的这些字段values（params）、lengths（params_len）、source（src[i].value，即参数的值）；ngx_http_script_compile可以对params和params_len字段进行修改；其实现如下： 12345678910111213141516171819202122232425262728293031ngx_int_t ngx_http_script_compile(ngx_http_script_compile_t *sc)&#123; for (i = 0; i &lt; sc-&gt;source-&gt;len; /* void */ ) &#123; //针对$document_root$fastcgi_script_name这种配置，会执行两次 if (sc-&gt;source-&gt;data[i] == &apos;$&apos;) &#123; if (ngx_http_script_add_var_code(sc, &amp;name) != NGX_OK) &#123; //name是变量名称 return NGX_ERROR; &#125; &#125; &#125;&#125; //同一个参数，值可能由多个变量组合而成，同一个参数可能会调用此方法多次static ngx_int_t ngx_http_script_add_var_code(ngx_http_script_compile_t *sc, ngx_str_t *name)&#123; index = ngx_http_get_variable_index(sc-&gt;cf, name); //获取变量的索引 //ngx_http_script_var_code_t结构体包含两个字段：code函数指针，计算为变量长度（方法内部查找索引为index的变量，返回其长度）；index为变量索引 code = ngx_http_script_add_code(*sc-&gt;lengths, sizeof(ngx_http_script_var_code_t), NULL); //存储到lengths，即params_len code-&gt;code = (ngx_http_script_code_pt) ngx_http_script_copy_var_len_code; code-&gt;index = (uintptr_t) index; //ngx_http_script_var_code_t结构体包含两个字段：code函数指针，拷贝变量内容（方法内部查找索引为index的变量，拷贝变量内容）；index为变量索引 code = ngx_http_script_add_code(*sc-&gt;values, sizeof(ngx_http_script_var_code_t), &amp;sc-&gt;main); //存储到values，即params code-&gt;code = ngx_http_script_copy_var_code; code-&gt;index = (uintptr_t) index; return NGX_OK;&#125; 最终params_len与params的内部存储结构入下图： 3.构造FastCGI请求方法ngx_http_fastcgi_create_request创建FastCGI请求，初始化请求内容（包括BEGIN_REQUEST、PARAMS和STDIN类型的请求消息）； 3.1FastCGI请求结构FastCGI应用即为nginx的upstream，输出缓冲区的类型为ngx_chain_t，是由多个buf组成的链表 1234struct ngx_chain_s &#123; ngx_buf_t *buf; ngx_chain_t *next;&#125;; nginx将FastCGI请求分为三个部分，由三个buf链成一个ngx_chain_s；nginx构造的FastCGI请求结构如下图所示； 其中第一部分主要包括fastcgi_param配置的参数以及HTTP请求的header，其他内容固定不变；第二部分是HTTP请求的body，其buf在解析HTTP请求时已经初始化好了，此处只需要将此buf添加到ngx_chain_s链中即可；第三部分内容固定； 3.2 计算请求第一部分长度为第一部分分配buf时，首先需要计算buf所需空间的大小；第一部分空间分为fastcgi_param参数与HTTP请求header；计算方法见下文： 1）计算fastcgi_param参数所需空间大小：1234567891011121314151617181920212223242526272829if (flcf-&gt;params_len) &#123; ngx_memzero(&amp;le, sizeof(ngx_http_script_engine_t)); ngx_http_script_flush_no_cacheable_variables(r, flcf-&gt;flushes); le.flushed = 1; le.ip = flcf-&gt;params_len-&gt;elts; //le.ip即为params_len存储的元素 le.request = r; while (*(uintptr_t *) le.ip) &#123; //循环计算索引参数key与value长度之和 lcode = *(ngx_http_script_len_code_pt *) le.ip; //key长度，lcode指向方法ngx_http_script_copy_len_code key_len = lcode(&amp;le); lcode = *(ngx_http_script_len_code_pt *) le.ip; //是否必传，lcode指向方法ngx_http_script_copy_len_code skip_empty = lcode(&amp;le); for (val_len = 0; *(uintptr_t *) le.ip; val_len += lcode(&amp;le)) &#123; //value长度，lcode指向方法ngx_http_script_copy_var_len_code（注意value可能又多个值组合而成） lcode = *(ngx_http_script_len_code_pt *) le.ip; &#125; le.ip += sizeof(uintptr_t); //跳参数之间分割的NULL if (skip_empty &amp;&amp; val_len == 0) &#123; //非必传参数，值为空时可跳过 continue; &#125; len += 1 + key_len + ((val_len &gt; 127) ? 4 : 1) + val_len; &#125;&#125; 2）HTTP请求header所需空间大小 1234567891011121314151617181920212223242526272829303132333435363738if (flcf-&gt;upstream.pass_request_headers) &#123; //是否需要向FastCGI应用传递header part = &amp;r-&gt;headers_in.headers.part; header = part-&gt;elts; for (i = 0; /* void */; i++) &#123; //header_params记录fastcgi_param是否配置了以HTTP_开始的参数，headers_hash存储此种类型的配置参数 if (flcf-&gt;header_params) &#123; for (n = 0; n &lt; header[i].key.len; n++) &#123; ch = header[i].key.data[n]; if (ch &gt;= &apos;A&apos; &amp;&amp; ch &lt;= &apos;Z&apos;) &#123; ch |= 0x20; &#125; else if (ch == &apos;-&apos;) &#123; ch = &apos;_&apos;; &#125; hash = ngx_hash(hash, ch); lowcase_key[n] = ch; &#125; if (ngx_hash_find(&amp;flcf-&gt;headers_hash, hash, lowcase_key, n)) &#123; //查询此HTTP请求头是否已经由fastcgi_param指令配置；有则忽略此HTTP请求头 ignored[header_params++] = &amp;header[i]; continue; &#125; n += sizeof(&quot;HTTP_&quot;) - 1; //请求头添加HTTP_前缀（n已经累加到header[i].key.len了） &#125; else &#123; n = sizeof(&quot;HTTP_&quot;) - 1 + header[i].key.len; //请求头添加HTTP_前缀 &#125; len += ((n &gt; 127) ? 4 : 1) + ((header[i].value.len &gt; 127) ? 4 : 1) + n + header[i].value.len; &#125;&#125; 3）创建第一部分buf 1234567891011121314151617181920if (len &gt; 65535) &#123; return NGX_ERROR;&#125; padding = 8 - len % 8;padding = (padding == 8) ? 0 : padding; size = sizeof(ngx_http_fastcgi_header_t) + sizeof(ngx_http_fastcgi_begin_request_t) + sizeof(ngx_http_fastcgi_header_t) /* NGX_HTTP_FASTCGI_PARAMS */ + len + padding + sizeof(ngx_http_fastcgi_header_t) /* NGX_HTTP_FASTCGI_PARAMS */ + sizeof(ngx_http_fastcgi_header_t); /* NGX_HTTP_FASTCGI_STDIN */ b = ngx_create_temp_buf(r-&gt;pool, size);cl = ngx_alloc_chain_link(r-&gt;pool);cl-&gt;buf = b; 3.3填充请求第一部分nginx的缓冲区buf主要关注以下四个字段：12345struct ngx_buf_s &#123; u_char *pos; //当buf所指向的数据在内存里的时候，pos指向的是这段数据开始的位置 u_char *last; //当buf所指向的数据在内存里的时候，last指向的是这段数据结束的位置 off_t file_pos; //当buf所指向的数据是在文件里的时候，file_pos指向的是这段数据的开始位置在文件中的偏移量 off_t file_last;//当buf所指向的数据是在文件里的时候，file_last指向的是这段数据的结束位置在文件中的偏移量 1）填充fastcgi_param参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445if (flcf-&gt;params_len) &#123; e.ip = flcf-&gt;params-&gt;elts; //e.ip是params e.pos = b-&gt;last; le.ip = flcf-&gt;params_len-&gt;elts; ////le.ip是params_len while (*(uintptr_t *) le.ip) &#123; lcode = *(ngx_http_script_len_code_pt *) le.ip; //key的长度 key_len = (u_char) lcode(&amp;le); lcode = *(ngx_http_script_len_code_pt *) le.ip; //是否必传 skip_empty = lcode(&amp;le); for (val_len = 0; *(uintptr_t *) le.ip; val_len += lcode(&amp;le)) &#123; //value的长度 lcode = *(ngx_http_script_len_code_pt *) le.ip; &#125; le.ip += sizeof(uintptr_t); if (skip_empty &amp;&amp; val_len == 0) &#123; //跳过 ………… &#125; *e.pos++ = (u_char) key_len; //填充key_len //填充value_len if (val_len &gt; 127) &#123; *e.pos++ = (u_char) (((val_len &gt;&gt; 24) &amp; 0x7f) | 0x80); *e.pos++ = (u_char) ((val_len &gt;&gt; 16) &amp; 0xff); *e.pos++ = (u_char) ((val_len &gt;&gt; 8) &amp; 0xff); *e.pos++ = (u_char) (val_len &amp; 0xff); &#125; else &#123; *e.pos++ = (u_char) val_len; &#125; //填充key和value的数据内容；key的填充方法为ngx_http_script_copy_code，value的填充方法ngx_http_script_copy_var_code， while (*(uintptr_t *) e.ip) &#123; code = *(ngx_http_script_code_pt *) e.ip; code((ngx_http_script_engine_t *) &amp;e); &#125; e.ip += sizeof(uintptr_t); //跳过参数之间分割的NULL &#125; b-&gt;last = e.pos;&#125; 2）填充HTTP请求头 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455if (flcf-&gt;upstream.pass_request_headers) &#123; part = &amp;r-&gt;headers_in.headers.part; header = part-&gt;elts; for (i = 0; /* void */; i++) &#123; for (n = 0; n &lt; header_params; n++) &#123; //上一步计算长度时，会记录跳过的header在ignored；填充阶段直接跳过 if (&amp;header[i] == ignored[n]) &#123; goto next; &#125; &#125; key_len = sizeof(&quot;HTTP_&quot;) - 1 + header[i].key.len; //填充key长度 if (key_len &gt; 127) &#123; *b-&gt;last++ = (u_char) (((key_len &gt;&gt; 24) &amp; 0x7f) | 0x80); *b-&gt;last++ = (u_char) ((key_len &gt;&gt; 16) &amp; 0xff); *b-&gt;last++ = (u_char) ((key_len &gt;&gt; 8) &amp; 0xff); *b-&gt;last++ = (u_char) (key_len &amp; 0xff); &#125; else &#123; *b-&gt;last++ = (u_char) key_len; &#125; val_len = header[i].value.len; //填充value长度 if (val_len &gt; 127) &#123; *b-&gt;last++ = (u_char) (((val_len &gt;&gt; 24) &amp; 0x7f) | 0x80); *b-&gt;last++ = (u_char) ((val_len &gt;&gt; 16) &amp; 0xff); *b-&gt;last++ = (u_char) ((val_len &gt;&gt; 8) &amp; 0xff); *b-&gt;last++ = (u_char) (val_len &amp; 0xff); &#125; else &#123; *b-&gt;last++ = (u_char) val_len; &#125; b-&gt;last = ngx_cpymem(b-&gt;last, &quot;HTTP_&quot;, sizeof(&quot;HTTP_&quot;) - 1); //填充HTTP_前缀 for (n = 0; n &lt; header[i].key.len; n++) &#123; //填充key数据内容 ch = header[i].key.data[n]; if (ch &gt;= &apos;a&apos; &amp;&amp; ch &lt;= &apos;z&apos;) &#123; ch &amp;= ~0x20; &#125; else if (ch == &apos;-&apos;) &#123; ch = &apos;_&apos;; &#125; *b-&gt;last++ = ch; &#125; b-&gt;last = ngx_copy(b-&gt;last, header[i].value.data, val_len); //填充value数据内容 next: continue; &#125;&#125; 3.4填充请求第二三部分HTTP请求的body同样存储在ngx_chain_t结构中，nginx需要遍历链表的所有buf，构造fastcgi的请求数据； 注意：nginx构造fastcgi请求时，第二部分请求（http_body）的长度最长为32K，当超过此限制时，HTTP请求体会被分割为多个http_body请求；入下图所示： 12345678910111213141516171819202122232425262728do &#123; b = ngx_alloc_buf(r-&gt;pool); b-&gt;pos = pos; pos += 32 * 1024; if (pos &gt;= body-&gt;buf-&gt;last) &#123; //数据小于32k，next赋值为1，结束while循环；否则就切割为了32K大小的数据包 pos = body-&gt;buf-&gt;last; next = 1; &#125; b-&gt;last = pos; len = (ngx_uint_t) (pos - b-&gt;pos); padding = 8 - len % 8; padding = (padding == 8) ? 0 : padding; cl-&gt;next = ngx_alloc_chain_link(r-&gt;pool); cl = cl-&gt;next; //添加http_body请求包到buf链表中 cl-&gt;buf = b; ………… b = ngx_create_temp_buf(r-&gt;pool, sizeof(ngx_http_fastcgi_header_t) + padding); cl-&gt;next = ngx_alloc_chain_link(r-&gt;pool); cl = cl-&gt;next; //添加padding与header请求包到buf链表中 cl-&gt;buf = b; &#125; while (!next); 实战4.1配置nginx配置如下： 12345678910111213141516171819202122232425http&#123; ………… fastcgi_connect_timeout 300; fastcgi_send_timeout 300; fastcgi_read_timeout 300; server &#123; listen 80; server_name localhost; root /home/xiaoju; index index.php index.html; location / &#123; fastcgi_index index.php; fastcgi_pass 127.0.0.1:9000; include fastcgi.conf; &#125; &#125;&#125; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;fastcgi_param QUERY_STRING $query_string;fastcgi_param REQUEST_METHOD $request_method;fastcgi_param CONTENT_TYPE $content_type;fastcgi_param CONTENT_LENGTH $content_length; 编写PHP脚本，只是简单的将post入参返回即可：123456&lt;?phpforeach($_POST as $key=&gt;$v)&#123; $ret[&apos;ret-&apos;.$key] = &apos;ret-&apos;.$v;&#125;echo json_encode($ret); 4.2FastCGI请求包我们GDB nginx worker进程； 查看FastCGI请求参数，在ngx_http_fastcgi_create_request方法添加断点，执行到函数最后一行（此时请求数据已经构造完成），输出数据存储在表达式r-&gt;upstream-&gt;request_bufs表示的缓冲区； 查看FastCGI应用（php-fpm）返回的数据，在ngx_http_fastcgi_process_record方法添加断点，方法入参ngx_http_fastcgi_ctx_t的pos和last分别指向读入数据的开始与结尾，此方法杜泽解析读入数据； 添加断点如下： 123456789Num Type Disp Enb Address What1 breakpoint keep y 0x0000000000418f05 in ngx_process_events_and_timers at src/event/ngx_event.c:203 inf 3, 2, 1 breakpoint already hit 17 times2 breakpoint keep y 0x000000000045b7fa in ngx_http_fastcgi_create_request at src/http/modules/ngx_http_fastcgi_module.c:735 inf 3, 2, 1 breakpoint already hit 4 times3 breakpoint keep y 0x000000000045c2af in ngx_http_fastcgi_create_request at src/http/modules/ngx_http_fastcgi_module.c:1190 inf 3, 2, 1 breakpoint already hit 4 times4 breakpoint keep y 0x000000000045a573 in ngx_http_fastcgi_process_record at src/http/modules/ngx_http_fastcgi_module.c:2145 inf 3, 2, 1 breakpoint already hit 1 time 执行到ngx_http_fastcgi_create_request函数结尾（断点3），打印r-&gt;upstream-&gt;request_bufs三个buf： 注意：gdb使用命令p打印字符串时，需设置set print element 0才不会省略部分字符串，否则字符串不会打印完全；@符号表示打印多少个字符（fastcgi请求时二进制数据，不能依据\\0判断结尾）；字符串显示时，显示‘\\222’时，为8进制表示，需转换为10进制计算才行；12345678910111213141516171819202122232425262728293031323334353637383940(gdb) p *r-&gt;upstream-&gt;request_bufs-&gt;buf-&gt;pos@1000$18 =\\001\\001\\000\\001\\000\\b\\000\\000 //8字节头部，type=1（BEGIN_REQUEST）\\000\\001\\000\\000\\000\\000\\000\\000 //8字节BEGIN_REQUEST数据包\\001\\004\\000\\001\\002\\222\\006\\000 //8字节头部，type=4（PARAMS），数据内容长度=2*256+146=658(不是8字节整数倍，需要填充6个字节)\\017\\025SCRIPT_FILENAME/home/xiaoju/test.php //key-value，格式为：keylen+valuelen+key+value\\f\\000QUERY_STRING\\016\\004REQUEST_METHODPOST\\f!CONTENT_TYPEapplication/x-www-form-urlencoded\\016\\002CONTENT_LENGTH19\\v\\tSCRIPT_NAME/test.php\\v\\nREQUEST_URI//test.php\\f\\tDOCUMENT_URI/test.php\\r\\fDOCUMENT_ROOT/home/xiaoju\\017\\bSERVER_PROTOCOLHTTP/1.1\\021\\aGATEWAY_INTERFACECGI/1.1\\017\\vSERVER_SOFTWAREnginx/1.6.2\\v\\tREMOTE_ADDR127.0.0.1\\v\\005REMOTE_PORT54276\\v\\tSERVER_ADDR127.0.0.1\\v\\002SERVER_PORT80\\v\\tSERVER_NAMElocalhost\\017\\003REDIRECT_STATUS200\\017dHTTP_USER_AGENTcurl/7.19.7 (x86_64-redhat-linux-gnu) libcurl/7.19.7 NSS/3.27.1 zlib/1.2.3 libidn/1.18 libssh2/1.4.2\\t\\tHTTP_HOSTlocalhost\\v\\003HTTP_ACCEPT*/*\\023\\002HTTP_CONTENT_LENGTH19\\021!HTTP_CONTENT_TYPEapplication/x-www-form-urlencoded\\000\\000\\000\\000\\000\\000 //6字节内容填充\\001\\004\\000\\001\\000\\000\\000\\000 //8字节头部，type=4（PARAMS），表示PARAMS请求结束\\001\\005\\000\\001\\000\\023\\005\\000 //8字节头部，type=5（STDIN），请求体数据长度19个字节 (gdb) p *r-&gt;upstream-&gt;request_bufs-&gt;next-&gt;buf-&gt;pos@20$19 = &quot;name=hello&amp;gender=1&quot; //HTTP请求体，长度19字节，需填充5个字节 (gdb) p *r-&gt;upstream-&gt;request_bufs-&gt;next-&gt;next-&gt;buf-&gt;pos@20$20 =\\000\\000\\000\\000\\000 //5字节填充\\001\\005\\000\\001\\000\\000\\000 //8字节头部，type=5（STDIN），表示STDIN请求结束 执行到方法ngx_http_fastcgi_process_record，打印读入请求数据： 12345678910111213(gdb)p *f-&gt;pos@1000$26 =\\001\\006\\000\\001\\000\\377\\001\\000 //8字节头部，type=6（STDOUT），返回数据长度为255字节（需要填充1个字节）Set-Cookie: PHPSESSID=3h9lmb2mvp6qlk1rg11id3akd3; path=/\\r\\n //返回数据内容，以换行符分隔Expires: Thu, 19 Nov 1981 08:52:00 GMT\\r\\nCache-Control: no-store, no-cache, must-revalidate\\r\\nPragma: no-cache\\r\\nContent-type: text/html; charset=UTF-8\\r\\n\\r\\n&#123;\\&quot;ret-name\\&quot;:\\&quot;ret-hello\\&quot;,\\&quot;ret-gender\\&quot;:\\&quot;ret-1\\&quot;&#125;\\000\\001\\003\\000\\001\\000\\b\\000\\000 //8字节头部，type=3（END_REQUEST），表示fastcgi请求结束，数据长度为8\\000\\000\\000\\000\\000m\\&quot; //8字节END_REQUEST数据 END_REQUEST请求数据体8个字节，其定义可以在php源码中查看： 12345678typedef struct _fcgi_end_request &#123; unsigned char appStatusB3; ////结束状态，0为正常 unsigned char appStatusB2; unsigned char appStatusB1; unsigned char appStatusB0; unsigned char protocolStatus; //为协议所处的状态，0为正常状态 unsigned char reserved[3];&#125; fcgi_end_request; 总结本文通过分析ngx_http_fastcgi_module模块构造FastCGI请求的代码，学习FastCGI协议格式，并通过GDB打印FastCGI请求与相应数据，以此对FastCGI协议有了更直观的理解。","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"},{"name":"cgi","slug":"cgi","permalink":"https://blog.xtcgch.ink/tags/cgi/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"vim常用命令","slug":"20190309-vi常用命令","date":"2019-03-09T02:26:37.000Z","updated":"2020-11-22T02:41:40.345Z","comments":true,"path":"vim常用命令/","link":"","permalink":"https://blog.xtcgch.ink/vim常用命令/","excerpt":"摘要：本章主要介绍vim编译器常用的快捷命令","text":"摘要：本章主要介绍vim编译器常用的快捷命令 移动 向上移动一行：k 向上移动9行：9k -&gt; n行：nk 移动到当前行行尾:$ 移动到当前行的第一个字符上:0(数字0) 移动到下一行的行尾:1$ 移动到下n行的行尾:n$ 在当前行上查找下一个字符x（向右方向）:fx 跳转到与当前光标下的括号相匹配的那一个括号:% ;( -&gt; ),) -&gt; ( 显示行号：set number(set nu) 关闭行号：set nonumber(set nonu) 显示光标位置：set ruler ma：在当前光标的位置标记一个书签，名字为a。书签名只能是小写字母。你看不见书签的存在，但它确实已经在那里了 &#39;`&#39;a , 到书签a处。注意这个不是单引号，它一般位于大部分键盘的1的左边 &#39;`&#39;.：到你上次编辑文件的地方。这个命令很有用，而且你不用自己去标记它。 w：光标往前移动一个词。 b： 光标往后移动一个词 ^：移动光标到当前行的第一个字母位置 H：移动光标到屏幕上面 M：移动光标到屏幕中间 L：移动光标到屏幕下面 查找替换 从光标向后查找整个关键词 从光标向前查找整个关键词 查找替换例子：: s/SEARCH/REPLACE: s/If/Since 将下一个”If”换成”Since”: %s/If/Since 将全部”If”换成”Since”: 1,3 s/If/Since/g 只对1,3行有效,如无前缀,只对当前行有效 选择文本 v 从光标当前位置开始，光标所经过的地方会被选中，再按一下v结束 V 从光标当前行开始，光标经过的行都会被选中，再按一下Ｖ结束 Ctrl + v 从光标当前位置开始，选中光标起点和终点所构成的矩形区域，再按一下Ｃtrl + v结束 ggVG 选中全部的文本， 其中gg为跳到行首，V选中整行，G末尾 删除文本 删除字符:x 删除3个字符：3x -&gt; n个字符：nx 删除一行:dd 删除换行符:j 撤销：u x 删除当前光标下的字符(“dl”的快捷命令) X 删除当前光标之前的字符(“dh”的快捷命令) D 删除自当前光标至行尾的内容(“d$”的快捷命令) dw 删除自当前光标至下一个word的开头 db 删除自当前光标至前一个word的开始 diw 删除当前光标所在的word(不包括空白字符) daw 删除当前光标所在的word(包括空白字符) dG 删除当前行至文件尾的内容 dgg 删除当前行至文件头的内容 复制文本 复制一个字符：y 复制一行：yy 复制n个字符：yn 复制一个单词：yw 粘贴文本 p:粘贴所有的复制和剪切内容 编辑文本 全文查找：/target,下一个：n,上一个：N -&gt; 下3个：3n,上3个：3N 在文本中查找下一个word:*,# 查匹配单词的开头：\\&lt; , 查匹配单词的结尾：> ,如 /the>不会匹配they Ctrl+N : 文本提示 ：缩进所有选择的代码 编辑文本 当前光标之前插入文本：i 当前光标之后插入文本：a 在当前行的下面另起一行插入文本：o 在当前行的上面另起一行插入文本：O 丢弃所有的修改并退出:”:q!” 放弃所有修改并重新载入该文件的原始内容:”:e!” 放弃所有操作并退出：qall 保存所有:wall 保存所有并退出:qwall 使用vimdiff查看不同:vimdiff main.c~ main.c 划分窗格 :split/vsplit 分隔一个窗口 new/vnew 创建一个新的窗口 sf {filename} 在新窗口中打开filename close 关闭当前窗口 only 关闭除当前窗口外所有窗口 ctrl-w h 到左面的窗口 ctrl-w j 到下面的窗口 ctrl-w k 到上面的窗口 ctrl-w l 到右面的窗口 ctrl-w t 到顶部的窗口 ctrl-w b 到底部的窗口","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"centos","slug":"centos","permalink":"https://blog.xtcgch.ink/tags/centos/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"一些有用的收藏","slug":"20190304-一些有用的收藏","date":"2019-03-04T14:51:31.000Z","updated":"2020-11-22T02:41:34.211Z","comments":true,"path":"一些有用的收藏/","link":"","permalink":"https://blog.xtcgch.ink/一些有用的收藏/","excerpt":"摘要：本文主要是记录那些在平时零碎时间看到的有趣的片段。","text":"摘要：本文主要是记录那些在平时零碎时间看到的有趣的片段。 好用的网站和工具1、临时邮箱 -&gt; 传送门 2、疯狂影视搜索 -&gt; 传送门 3、PocketAnimation（口袋动画） -&gt; 传送门 4、图像在线编辑工具 -&gt; 传送门 5、磁盘文件扫描工具 -&gt; 传送门 6、录屏软件 -&gt; 传送门 7、Inpaint图片修改工具 -&gt; 传送门 8、ScreenToGif（2M）–最让人依赖的动态图捕捉工具 -&gt; 传送门 9、AI人工智能图片放大 -&gt; 传送门 冷技巧1、用支付宝免费下载全网论文 -&gt; 办理浙江图书馆读者证","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"收藏","slug":"收藏","permalink":"https://blog.xtcgch.ink/tags/收藏/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"Lnux信号的相关知识","slug":"20190215-Linux信号相关知识点","date":"2019-02-15T01:06:33.000Z","updated":"2020-11-22T02:41:31.300Z","comments":true,"path":"Linux常见信号/","link":"","permalink":"https://blog.xtcgch.ink/Linux常见信号/","excerpt":"摘要：简单的介绍常用信号，信号的三种状态、信号的处理方式和信号集。","text":"摘要：简单的介绍常用信号，信号的三种状态、信号的处理方式和信号集。 Linux常用信号在linux下有很多信号，按可靠性分为可靠信号和非可靠信号，按时间分为实时信号和非实时信号，linux进程也有三种方式来处理收到的信号： 忽略信号，即对信号不做任何处理，其中，有两个信号不能忽略：SIGKILL及SIGSTOP； 捕捉信号。定义信号处理函数，当信号发生时，执行相应的处理函数； 执行缺省操作，Linux对每种信号都规定了默认操作。 Linux进程对实时信号的缺省反应是进程终止。但是对于高性能服务器编程来说，这是致命的缺陷，对于这类服务器需要保证在收到各种信号后仍然可以可靠运行，所以我们需要在理解各种信号的缘由和正确的处理方式。本文将笔者经常碰到的一些信号进行整理，结合自己的使用经验简要分析。 SIGHUP 和控制台操作有关，当控制台被关闭时系统会向拥有控制台sessionID的所有进程发送HUP信号，默认HUP信号的action是 exit，如果远程登陆启动某个服务进程并在程序运行时关闭连接的话会导致服务进程退出，所以一般服务进程都会用nohup工具启动(该命令就是让忽略该信号)或写成一个 daemon(利用setsid进行)。 以下五组可以放在一块类比 SIGINT 终止进程，通常我们的Ctrl+C就发送的这个消息。 SIGQUIT 和SIGINT类似, 但由QUIT字符(通常是Ctrl- / )来控制. 进程收到该消息退出时会产生core文件。 SIGKILL 消息编号为9，我们经常用kill -9来杀死进程发送的就是这个消息，程序收到这个消息立即终止，这个消息不能被捕获，封锁或这忽略，所以是杀死进程的终极武器。 SIGTERM 是不带参数时kill默认发送的信号，默认是杀死进程。 SIGSTOP 停止进程的执行，同SIGKILL一样不可以被应用程序所处理，注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行。 SIGCONT 当SIGSTOP发送到一个进程时，通常的行为是暂停该进程的当前状态。如果发送SIGCONT信号，该进程将仅恢复执行。除了其他目的，SIGSTOP和SIGCONT用于Unix shell中的作业控制，无法捕获或忽略SIGCONT信号。 SIGPIPE 这个是向一个没有读进程的管道写数据产生的错误，这种解释过于官方。在网络编程中这个信号发生在如果客户端已经关闭了套接字, 而服务器调用了一次write，服务器就会收到一个RST segment，如果服务器再次调用write，这个时候就会产生SIGPIPE信号，系统默认的处理方式是关掉这个进程， 但是对于一个高可用的服务器程序来说，需要手动处理这个信号，所以你会看到许多服务器程序代码会在前面显式加上signal (SIGPIPE, SIG_IGN)来忽略这个信号。 SIGCHILD 这个同样是高性能服务器需要关注的信号，如果服务器采用fork产生的子进程推出后要调用wait进行资源回收，防止僵尸进程的产生，但是如果程序对子进程退出后的状态不感兴趣的话可以调用signal(SIGCHLD,SIG_IGN); 交给系统init去回收。子进程也不会产生僵尸进程了。 SIGSEGV 就是SegmentFault 试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据，官方举得三个例子是： buffer overflow — usually caused by a pointer reference out of range. 野指针stack overflow — please keep in mind that the default stack size is 8192K. 栈溢出illegal file access — file operations are forbidden on our judge system. 非法文件访问SIGBUS 指针所对应的地址是有效地址，但总线不能正常使用该指针。通常是未对齐的数据访问所致。试图访问一块无文件内容对应的内存区域，比如超过文件尾的内存区域，或者以前有文件内容对应，现在为另一进程截断过的内存区域。 SIGURG I/O紧急信号，也就是tcp传输带外数据时使用，但是tcp手册 RFC6093中已经不建议使用紧急指针了，所以这个信号也就没什么用了。 SIGIO 当描述符上可以进行I/O时产生这个信号，这时五大IO模型中信号驱动IO模型的实现信号。 SIGALRM 时钟定时信号, 计算的是实际的时间或时钟时间.alarm函数使用该信号. 信号的三种状态 信号递达：实际执行信号的处理动作。 信号未决：信号从产生到递达之间的状态。 进程可以选择阻塞（block）某个信号。一旦该信号被阻塞就不会被抵达，只有解除阻塞才可被递达。 被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作。 阻塞与忽略是不同的，只要信号阻塞就不会被递达，忽略是在递达之后可选的一种处理动作。 信号的三种处理方式 忽略此信号。 执⾏行该信号的默认处理动作（终止该信号）。 提供⼀个信号处理函数（自定义动作）,要求内核在处理该信号时切换到用户态执行这个处理函数,这种方式称为捕捉(Catch)一个信号。 这三种处理方式的信号状态都为信号递达。 信号在内核中的表示（三张表）这3张表分别对应3种状态： 信号阻塞（block） 信号未决（pending） 信号递达—自定义捕捉函数（handler） 其中，前两张表都是位图（BitSet）来存储的。block表中信号被阻塞就将相应位置1，否则置0。而pending表中，若置1则表示信号存在，0则相反。即可这样说。pending表中的数据是判断信号是否存在的唯一依据。 结合上图就可以知道： SIGHUP信号未阻塞也未产生过，但当它递达时就会执行默认处理动作。 SIGINT信号产生过，但已被阻塞。所以暂时不能递达。虽然它的处理动作是忽略。但在没有解除阻塞之前不能忽略这个信号，因为进程仍有机会改变处理动作之后再解除阻塞。 SIGQUIT信号未产生过，一旦产⽣将被阻塞，它的处理动作是用户自定义的捕捉函数handler。 那么可以将信号的三张表总结成这样： 如果一个信号被block，若收到信号，则该信号必定被Pending。 一个进程收到信号时不会立即递达，在此过程中一直被Pending。 一个标准：如果在进程解除对信号的阻塞之前，该信号产生过多次，将如何处理呢？ 答：POSIX.1允许系统递送该信号一次或多次。 Linux是这样规定的：常规信号在递达之前产生多次只记一次，而实时信号在递达之前产生多从可以依次放在一个队列中。 信号集概念信号集是一个包含了所有信号的集合。信号的发送与接收都是以信号集为单位进行发送。 信号集Sigset_t结构在上图中，未决和阻塞标志都可以用相同的数据结构（位图）存储。所以当然可以用同一数据类型来表示，这就是sigset_t. sigset_t称为信号集，这个类型可以表示每个信号的“有效”或“无效”状态。 在阻塞信号集其含义是该信号是否被阻塞；在未决信号集中就代表该信号是否处于未决状态。 操作函数123456789#include&lt;signal.h&gt;int sigemptyset(sigset_t *set);//初始化set所指的信号集，使其中所有信号的对应bit清零，表示该信号集不包含任何有效信号。int sigfillset(sigset_t *set);//初始化set所指的信号集，使其中所有信号的对应bit置位，表示该信号集的有效信号包括系统支持的所有信号。int sigaddset(sigset_t *set,int signo);int sigdelset(sigset_t *set,int signo);int sigismember(const sigset_t *set,int signo);//是一个布尔函数，用于判断一个信号集的有效信号中是否包含某种信号，若包含则返回1，不包含返回0，出错返回-1. 除了sigismember，其他四种函数都是成功返回0，出错返回-1. Sigprocmask函数调用函数Sigprocmask可以获取或更改进程的信号屏蔽字（阻塞信号集） 12#include&lt;signal.h&gt;int sigprocmask(int how,const sigset_t *set,sigset_t *oset);//返回值：成功返回0，出错返回-1. 参数：how参数的可选值： oset：原来的信号屏蔽字。 如果oset和set都是非空指针，则先将原来的信号屏蔽字备份到oset中，然后根据set和how参数更改信号屏蔽字。 注：如果调用sigprocmask解除了对当前若干个未决信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。 Sigpending函数读取当前进程的未决信号集 12#include&lt;signal.h&gt;int Sigpending（sigset_t *set）；//返回值：成功返回0，出错返回-1. Demo下面来进行代码测验：阻塞SIGINT信号，按Ctrl-c将SIGINT信号处于未决状态。比特位变为1.1234567891011121314151617181920212223242526272829303132333435363738#include&lt;stdio.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;void handler(int signo)&#123; printf(&quot;get a %d signo\\n&quot;,signo); exit(1);&#125;void show_pending(sigset_t *pending)&#123; int i=1; for(;i&lt;32;i++) &#123; if(sigismember(pending,i))&#123; printf(&quot;1&quot;); &#125;else&#123; printf(&quot;0&quot;); &#125; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; sigset_t set,oset,pending; sigemptyset(&amp;set);//初始化 sigaddset(&amp;set,2);//添加2号信号 signal(2,handler); sigprocmask(SIG_SETMASK,&amp;set,&amp;oset);//设置阻塞信号屏蔽字 int count=0; while(1)&#123; sigpending(&amp;pending);//获取当前未决信号 show_pending(&amp;pending); sleep(1); &#125; return 0;&#125; 解除2号信号的阻塞状态，使其抵达。捕捉到2号信号后，信号集数据又从1变0，变为以前的状态。再次crtl+c后，就不会发生1中的变化了。 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;signal.h&gt;#include&lt;unistd.h&gt;#include&lt;stdlib.h&gt;void handler(int signo)&#123; printf(&quot;get a %d signo\\n&quot;,signo);// exit(1);&#125;void show_pending(sigset_t *pending)&#123; int i=1; for(;i&lt;32;i++) &#123; if(sigismember(pending,i))&#123; printf(&quot;1&quot;); &#125;else&#123; printf(&quot;0&quot;); &#125; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; sigset_t set,oset,pending; sigemptyset(&amp;set); sigaddset(&amp;set,2); signal(2,handler); sigprocmask(SIG_SETMASK,&amp;set,&amp;oset); int count=0; while(1)&#123; sigpending(&amp;pending); show_pending(&amp;pending); sleep(1); count++; if(count==15)&#123; sigprocmask(SIG_SETMASK,&amp;oset,NULL);//解除了屏蔽 &#125; &#125; return 0;&#125; 总结信号是Linux系统编程的一个重要概念，要尽快掌握。","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.xtcgch.ink/tags/Linux/"},{"name":"信号","slug":"信号","permalink":"https://blog.xtcgch.ink/tags/信号/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"机器学习入门","slug":"20190121-机器学习入门","date":"2019-01-21T02:36:00.000Z","updated":"2020-11-22T02:27:10.101Z","comments":true,"path":"机器学习入门/","link":"","permalink":"https://blog.xtcgch.ink/机器学习入门/","excerpt":"摘要：这是本文主要是机器学习的笔记！","text":"摘要：这是本文主要是机器学习的笔记！ 脑图 其他模板的标题 1、笔记 定义 如果一个程序可在任务T上，随着经验E的增加，效果P随之增加，则这个程序可以从经验中学习。 三个要素 数据、算法、算力 应用概述 预测和分类 图像识别、语音识别和自然语言处理 神经网络的搭建 搭建神经网络的八股：准备、前传、后传和迭代 准备：import，常量定义，生成数据集 前向传播：定义输入、参数和输出 反向传播：定义损失函数、反向传播方法 迭代：生成会话、训练STEPS轮 神经网络的优化 常见函数 损失函数 激活函数 relu sigmold tanh 优化内容 损失函数 学习率 滑动平均 正则化 损失函数 激活函数 总结","categories":[{"name":"人工智能","slug":"人工智能","permalink":"https://blog.xtcgch.ink/categories/人工智能/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://blog.xtcgch.ink/tags/机器学习/"}],"keywords":[{"name":"人工智能","slug":"人工智能","permalink":"https://blog.xtcgch.ink/categories/人工智能/"}]},{"title":"【代码】管道使用例子","slug":"20190118-管道使用例子","date":"2019-01-18T04:21:45.000Z","updated":"2020-11-22T02:27:50.717Z","comments":true,"path":"管道使用例子/","link":"","permalink":"https://blog.xtcgch.ink/管道使用例子/","excerpt":"摘要：本文是匿名管道和命名管道在CentOS7下的使用例子。","text":"摘要：本文是匿名管道和命名管道在CentOS7下的使用例子。 1、demo1匿名管道的例子 12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#define MAXLINE 1024int main(void)&#123; int n; int fd[2]; pid_t pid; char line[MAXLINE]; if (pipe(fd) &lt; 0) &#123; perror(&quot;pipe&quot;); exit(1); &#125; pid = fork(); if (pid &lt; 0) &#123; perror(&quot;fork&quot;); exit(1); &#125; else if (pid &gt; 0) /* parent */ &#123; close(fd[0]); // 关闭读端 write(fd[1], &quot;hello world\\n&quot;, 12); &#125; else /* child */ &#123; close(fd[1]); // 关闭写端 n = read(fd[0], line, MAXLINE); write(STDOUT_FILENO, line, n); &#125; return 0;&#125; 2、demo2命名管道的例子 进程A创建管道(mkfifo) -&gt; 进程A写打开管道(open) -&gt; 进程B读打开管道(open) -&gt; 进程A开始往管道里写数据(write) -&gt; 进程B从管道中读数据(read) -&gt; 进程A关闭管道(close) -&gt; 进程B关闭管道(close) -&gt; 删除管道(unlink) 进程A：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;unistd.h&gt;using namespace std;#define PIPENAME &quot;pipetest&quot;int main()&#123; // 创建管道 if(mkfifo(PIPENAME, 0666) &lt; 0) &#123; cout&lt;&lt;&quot;mkfifo&quot;&lt;&lt;endl; return -1; &#125; // 写打开管道 int fd = open(PIPENAME, O_WRONLY); if(-1 == fd) &#123; cout&lt;&lt;&quot;open&quot;&lt;&lt;endl; return -1; &#125; unlink(PIPENAME); int i = 0; for(i = 0; i &lt; 10; i++) &#123; write(fd, &amp;i, sizeof(i)); cout&lt;&lt;&quot;i:&quot;&lt;&lt;i&lt;&lt;endl; sleep(1); // 这个是以秒为单位挂起 &#125; // 关闭管道 close(fd); return 0;&#125; 进程B： 123456789101112131415161718192021222324252627282930313233343536#include&lt;sys/stat.h&gt;#include&lt;fcntl.h&gt;#include&lt;iostream&gt;#include&lt;unistd.h&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;#define PIPENAME &quot;pipetest&quot;int main()&#123; // 读打开管道 int fd = open(PIPENAME, O_RDONLY); if(-1 == fd) &#123; cout&lt;&lt;&quot;open&quot;&lt;&lt;endl; return -1; &#125; int num = 0; int i = 0; for(i = 0; i &lt; 10; i++) &#123; read(fd, &amp;num, sizeof(int)); cout&lt;&lt;&quot;num:&quot;&lt;&lt;num&lt;&lt;endl; fflush(stdout); // 强制刷新输出缓冲区 &#125; close(fd); return 0;&#125;","categories":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}],"tags":[{"name":"管道","slug":"管道","permalink":"https://blog.xtcgch.ink/tags/管道/"},{"name":"posix","slug":"posix","permalink":"https://blog.xtcgch.ink/tags/posix/"}],"keywords":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}]},{"title":"【代码】posix消息队列使用例子","slug":"20190117-posix消息队列使用例子","date":"2019-01-17T07:36:54.000Z","updated":"2020-11-22T02:28:23.108Z","comments":true,"path":"posix消息队列使用例子/","link":"","permalink":"https://blog.xtcgch.ink/posix消息队列使用例子/","excerpt":"摘要：本章是关于posix消息队列的测试例子，相关解说在其他文章中。","text":"摘要：本章是关于posix消息队列的测试例子，相关解说在其他文章中。 1. demo1 测试消息队列的获取特性的函数 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;cstring&gt; #include &lt;errno.h&gt;#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;mqueue.h&gt;#include &lt;cstdlib.h&gt; using namespace std; int main()&#123; mqd_t mqID; mqID = mq_open(&quot;/anonymQueue&quot;, O_RDWR | O_CREAT, 0666, NULL); if (mqID &lt; 0) &#123; cout&lt;&lt;&quot;open message queue error...&quot;&lt;&lt;strerror(errno)&lt;&lt;endl; return -1; &#125; mq_attr mqAttr; if (mq_getattr(mqID, &amp;mqAttr) &lt; 0) &#123; cout&lt;&lt;&quot;get the message queue attribute error&quot;&lt;&lt;endl; return -1; &#125; cout&lt;&lt;&quot;mq_flags:&quot;&lt;&lt;mqAttr.mq_flags&lt;&lt;endl; cout&lt;&lt;&quot;mq_maxmsg:&quot;&lt;&lt;mqAttr.mq_maxmsg&lt;&lt;endl; cout&lt;&lt;&quot;mq_msgsize:&quot;&lt;&lt;mqAttr.mq_msgsize&lt;&lt;endl; cout&lt;&lt;&quot;mq_curmsgs:&quot;&lt;&lt;mqAttr.mq_curmsgs&lt;&lt;endl;&#125; 2. demo2 使用消息队列进行数据的收发 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;errno.h&gt; #include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;mqueue.h&gt;#include &lt;cstdlib.h&gt; using namespace std; int main()&#123; mqd_t mqID; mqID = mq_open(&quot;/anonymQueue&quot;, O_RDWR | O_CREAT | O_EXCL, 0666, NULL); if (mqID &lt; 0) &#123; if (errno == EEXIST) &#123; mq_unlink(&quot;/anonymQueue&quot;); mqID = mq_open(&quot;/anonymQueue&quot;, O_RDWR | O_CREAT, 0666, NULL); &#125; else &#123; cout&lt;&lt;&quot;open message queue error...&quot;&lt;&lt;strerror(errno)&lt;&lt;endl; return -1; &#125; &#125; if (fork() == 0) &#123; mq_attr mqAttr; mq_getattr(mqID, &amp;mqAttr); char *buf = new char[mqAttr.mq_msgsize]; for (int i = 1; i &lt;= 5; ++i) &#123; if (mq_receive(mqID, buf, mqAttr.mq_msgsize, NULL) &lt; 0) &#123; cout&lt;&lt;&quot;receive message failed. &quot;; cout&lt;&lt;&quot;error info:&quot;&lt;&lt;strerror(errno)&lt;&lt;endl; continue; &#125; cout&lt;&lt;&quot;receive message &quot;&lt;&lt;i&lt;&lt;&quot;: &quot;&lt;&lt;buf&lt;&lt;endl; &#125; exit(0); &#125; char msg[] = &quot;yuki&quot;; for (int i = 1; i &lt;= 5; ++i) &#123; if (mq_send(mqID, msg, sizeof(msg), i) &lt; 0) &#123; cout&lt;&lt;&quot;send message &quot;&lt;&lt;i&lt;&lt;&quot; failed. &quot;; cout&lt;&lt;&quot;error info:&quot;&lt;&lt;strerror(errno)&lt;&lt;endl; &#125; cout&lt;&lt;&quot;send message &quot;&lt;&lt;i&lt;&lt;&quot; success. &quot;&lt;&lt;endl; sleep(1); &#125;&#125; 3. 编译命令 g++ -lrt -o test main.cpp","categories":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}],"tags":[{"name":"posix","slug":"posix","permalink":"https://blog.xtcgch.ink/tags/posix/"},{"name":"消息队列","slug":"消息队列","permalink":"https://blog.xtcgch.ink/tags/消息队列/"}],"keywords":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}]},{"title":"【原理】posix消息队列","slug":"20190115-posix消息队列","date":"2019-01-15T13:03:42.000Z","updated":"2020-11-22T02:28:02.002Z","comments":true,"path":"posix消息队列/","link":"","permalink":"https://blog.xtcgch.ink/posix消息队列/","excerpt":"摘要：消息队列是一种异步处理数据的方式，本文只讲posix标准下的系统级的消息队列。","text":"摘要：消息队列是一种异步处理数据的方式，本文只讲posix标准下的系统级的消息队列。 脑图 1、概述1.1 简介消息队列是Linux IPC中很常用的一种通信方式，它通常用来在不同进程间发送特定格式的消息数据。 消息是从人类自然语言的角度来称呼，从技术角度来看就是一个数据结构，如字符串，结构体或者类，等等。消息队列中的每条消息具有以下属性： 一个表示优先级的整数 消息的数据部分的长度 消息数据本身 POSIX消息队列的一个可能的设计是一个如下图所示的消息链表，链表头部有消息队列的属性信息。 1.2 分类消息队列常有以下种类： System V消息队列 posix消息队列 自定义的各种语言的消息队列 其中前2种属于系统级别，可以通过系统调用来进行使用。最后一种是用户自己实现和维护的。 1.3 描述符和消息队列的关系消息队列描述符是一个进程级别的句柄，它引用了系统层面的打开着的消息队列描述表中的一个条目，而该条目则引用了一个消息队列对象。 1.4 特性1.5 评价（1）优点 （2）缺点 （3）限制 POSIX消息队列本身的限制就是mq_attr中的mq_maxmsg和mq_msgsize， 分别用于限定消息队列中的最大消息数和每个消息的最大字节数。 这两个参数可以在调用mq_open创建一个消息队列的时候设定。当这个设定是受到系统内核限制的。 2、操作2.1 打开 头文件：mqueue.h API:mqd_t mq_open(const char name, int oflag,…/ mode_t mode, struct mq_attr attr /); name:必填，消息队列的名称 oflag：必填，打开消息队列的选项参数，如下表所示： O_CREAT：队列不存在时创建 O_EXCL：与O_CREAT一起创建队列，如果已经存在同名消息队列，则返回失败。 O_RDONLY:只读 O_WRONLY:只写 O_RDWR:可写可读 O_NONBLOCK:以非阻塞方式打开。打开失败会返回EAGAIN错误。 mode：选填 attr：选填 返回：成功-&gt;消息队列描述符（mqd_t类型），失败-&gt;-1 说明： O_CREAT和O_EXCL一起使用时，如果此时已经存在同名的消息队列，则返回失败。 2.2 关闭一个消息队列 头文件： API：mqd_t mq_close(mqd_t mqdes); mqdes：消息队列描述符 返回：成功-&gt;消息队列描述符（mqd_t类型），失败-&gt;-1 说明：close()函数只是断开当前进程与消息队列的关联。删除消息队列需要使用mq_unlick()函数。 2.3 删除一个消息队列 头文件：mqueue.h API:mqd_t mq_unlink(const char * name); name：消息队列的名称 返回：成功-&gt;消息队列描述符（mqd_t类型），失败-&gt;-1 说明：mq_unlink函数被调用时首先打上了删除消息队列的标记，当所有的进程都退出使用消息队列后，该消息队列才真正被删除。 2.4 发送消息 头文件：mqueue.h 函数：mqd_t mq_send(mqd_t mqdes, const char * msg_ptr,size_t msg_len, unsigned msg_prio); mqdes：消息队列描述符 msg_ptr：指向缓冲区的指针 msg_len：要发送的数据长度，单位-&gt;字节 msg_prio：优先级 返回：成功-&gt;消息队列描述符（mqd_t类型），失败-&gt;-1 说明： 函数:int mq_timedsend(mqd_t mqdes, char msg_ptr, size_t msg_len,unsigned int msg_prio, const struct timespec abs_timeout) mqdes:消息队列描述符 msg_ptr:指向接收数据的缓冲区的指针 msg_len:数据长度 msg_prio:消息优先级 abs_timeout:超时时间 返回：成功-&gt;0，失败-&gt;-1 说明： 2.5 接收消息 头文件：mqueue.h 函数：mqd_t mq_receive(mqd_t mqdes, char msg_ptr, size_t msg_len, unsigned msg_prio); mqdes:消息队列描述符 msg_ptr:指向要存储的缓冲区的指针 msg_len:接收数据的长度，单位-&gt;字节 msg_prio:优先级 返回：成功-&gt;消息队列描述符（mqd_t类型），失败-&gt;-1 说明： 函数：ssize_t mq_timedreceive(mqd_t mqdes, char msg_ptr, size_t msg_len,unsigned int msg_prio, const struct timespec abs_timeout) mqdes:消息队列描述符 msg_ptr:指向接收数据的缓冲区的指针 msg_len:数据长度 msg_prio:消息优先级 abs_timeout:超时时间 返回：成功-&gt;接收的字节数，失败-&gt;-1 说明： 2.6 获取消息队列特性 头文件：mqueue.h 函数：mq_getattr(mqd_t mqdes,struct mq_attr * attr); mqdes: attr:消息队列的属性，包含一下四个属性 long mq_flags //消息队列的标志：0或O_NONBLOCK,用来表示是否阻塞 long mq_maxmsg //消息队列的最大消息数 long mq_msgsize //消息队列中每个消息的最大字节数 long mq_curmsgs //消息队列中当前的消息数目 返回：成功返回0，失败返回-1 说明： 2.7 设置消息队列的特性 头文件：msqueue.h 函数:mqd_t mq_setattr(mqd_t mqdes, struct mq_attr newattr, struct mq_attr oldattr); mqdes:消息队列描述符 newattr:新的特性 oldattr:旧的特性 返回：成功-&gt;消息队列描述符（mqd_t类型），失败-&gt;-1 说明： 2.8 消息通知 头文件：msqueue.h 函数:int mq_notify(mqd_t mqdes, const struct sigevent * notification); mqdes:消息队列描述符 notification:新的特性 返回：成功-&gt;0，失败-&gt;-1 说明： 3、其他API和数据结构 4、使用流程 5、应用场景 6、demo传送门 总结 目前只做过demo，暂无总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"posix","slug":"posix","permalink":"https://blog.xtcgch.ink/tags/posix/"},{"name":"消息队列","slug":"消息队列","permalink":"https://blog.xtcgch.ink/tags/消息队列/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】posix内存映射","slug":"20190115-内存映射","date":"2019-01-15T12:53:09.000Z","updated":"2020-11-22T02:41:24.691Z","comments":true,"path":"posix内存映射/","link":"","permalink":"https://blog.xtcgch.ink/posix内存映射/","excerpt":"摘要：内存映射是Linux系统中IPC的一种方式，对于学习Linux的系统原理或是在Linux系统下进行编程都有很大的帮助。","text":"摘要：内存映射是Linux系统中IPC的一种方式，对于学习Linux的系统原理或是在Linux系统下进行编程都有很大的帮助。 脑图 1、概述1.1 简介1.2 特性1.3 评价（1）优点 （2）缺点 （3）限制 2、操作2.1 创建2.2 使用2.3 删除 3、应用场景 4、API 5、使用流程 6、demo 总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"posix","slug":"posix","permalink":"https://blog.xtcgch.ink/tags/posix/"},{"name":"内存映射","slug":"内存映射","permalink":"https://blog.xtcgch.ink/tags/内存映射/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】posix信号量","slug":"20190115-posix信号量","date":"2019-01-15T12:50:33.000Z","updated":"2020-11-22T02:41:19.234Z","comments":true,"path":"posix信号量/","link":"","permalink":"https://blog.xtcgch.ink/posix信号量/","excerpt":"摘要：信号量对于线程或是进程间同步是非常重要的，是每个Linux开发人员应该掌握的一个知识点。","text":"摘要：信号量对于线程或是进程间同步是非常重要的，是每个Linux开发人员应该掌握的一个知识点。 脑图 1、概述1.1 简述1.2 分类1.3 特点1.4 评价（1）优点 （2）缺点 （3）限制 2、操作2.1 命名信号量的操作（1）打开和创建 （2）关闭 （3）删除 2.2 未命名信号量（1）打开和创建 （2）关闭 （3）删除 2.3 信号量的其他操作（1）等待一个信号量 （2）发布一个信号量 （3）获取信号量的当前值 3、应用场景 4、其他数据结构和API 5、使用流程 6、demo传送门:https://unistd68.yancoder.com/ 总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"posix","slug":"posix","permalink":"https://blog.xtcgch.ink/tags/posix/"},{"name":"信号量","slug":"信号量","permalink":"https://blog.xtcgch.ink/tags/信号量/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】posix共享内存","slug":"20190115-posix共享内存","date":"2019-01-15T12:48:27.000Z","updated":"2020-11-22T02:36:04.587Z","comments":true,"path":"posix共享内存/","link":"","permalink":"https://blog.xtcgch.ink/posix共享内存/","excerpt":"摘要：posix共享内存是IPC的一种方式，相似地，还有System V共享内存，本文只讲posix标准下的共享内存知识。","text":"摘要：posix共享内存是IPC的一种方式，相似地，还有System V共享内存，本文只讲posix标准下的共享内存知识。 脑图 1、概述1.1 简介1.2 特性1.3 评价（1）优点 （2）缺点 （3）限制 2、操作2.1 创建2.2 删除2.3 使用 3、使用场景 4、API 5、使用流程 6、demo 总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"共享内存","slug":"共享内存","permalink":"https://blog.xtcgch.ink/tags/共享内存/"},{"name":"posix","slug":"posix","permalink":"https://blog.xtcgch.ink/tags/posix/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【代码】CPP常见错误汇总","slug":"20190112-CPP常见错误汇总","date":"2019-01-12T10:17:51.000Z","updated":"2020-11-22T02:36:20.988Z","comments":true,"path":"CPP常见错误汇总/","link":"","permalink":"https://blog.xtcgch.ink/CPP常见错误汇总/","excerpt":"摘要：本文主要记录在编译、开发和其他场景下遇到的问题和解决方案！","text":"摘要：本文主要记录在编译、开发和其他场景下遇到的问题和解决方案！ 编译错误类makefile的语法错误（一）（1）错误信息 *** missing separator. Stop. （2）问题描述 在使用makefile时遇到的报错 （3）场景描述 操作系统：CentOS 7 ，64位 编译环境：g++,gcc 4.8.5版本，root权限 （4）截图 （5）问题分类 makefile （6）问题分析和解决方案 makefile中语句的缩进必须用tab键 （7）总结 对makefile不熟悉，多加训练 直接复制内容到makefile，有可能会引起相同的问题 g++编译错误类（1）错误信息 undefined reference to &#39;mq_open&#39; (2)问题描述 在编译posix消息队列程序时报错 （3）场景描述 操作系统：CentOS 7 ，64位 编译环境：g++,gcc 4.8.5版本，root权限 （4）截图 （5）问题分类 posix 消息队列 （6）问题分析和解决方案 在编译时添加 -lrt 命令 （7）总结 文件格式错误（1）错误信息 /bin/bash^M: bad interpreter错误解决方法 （2）问题描述 在windows系统中创建sh文件，然后在centos7系统中运行shell脚本 （3）场景描述 操作系统：CentOS 7 ，64位 编译环境：g++,gcc 4.8.5版本，root权限 4）截图 略 5）问题分类 bash shell （6）问题分析和解决方案 由于是在windows系统中创建的文件，文件的格式和Linux系统中的文件格式有区别，特别是sh这样的可执行文本 打开文件，使用命令set ff?检查，看看是不是dos字样，如果是，则将执行命令set ff=unix，然后执行命令wq进行保存更改，退出重进即可 开发错误类","categories":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}],"tags":[{"name":"错误汇总","slug":"错误汇总","permalink":"https://blog.xtcgch.ink/tags/错误汇总/"}],"keywords":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}]},{"title":"【其他】markdown语法","slug":"20190112-markdown语法","date":"2019-01-12T05:54:45.000Z","updated":"2020-11-22T02:41:16.258Z","comments":true,"path":"markdown语法/","link":"","permalink":"https://blog.xtcgch.ink/markdown语法/","excerpt":"摘要：这是摘要！","text":"摘要：这是摘要！ 大纲（TOC）说明：使用[toc/TOC]来根据各级标题来生成文本大纲视图。 备注：很多markdown工具对toc支持不友好。github的博客会自动生成文本大纲。 标题在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，尽量控制在四级标题以内。 注意：在#之后统一使用空格隔开，如# 一级标题 字体（1）加粗 说明：要加粗的文字左右分别用2个 * 号包起来 示例：加粗 用法：**加粗** （2）斜体 说明：要倾斜的文字左右分别用1个 * 号包起来 示例：斜体 用法：*斜体* （3）斜体加粗 说明：要倾斜和加粗的文字左右分别用3个 * 号包起来 示例：斜体加粗 用法：***斜体加粗*** （4）删除线 说明：要加删除线的文字左右分别用2个 ~ 号包起来 示例：删除线 用法：~~删除线~~ 引用（1）单层引用 在引用的文字前加&gt;即可。如： 这是单层引用部分 （2）嵌套引用 使用多个连起来的&gt;，&gt;的个数表示嵌套的层数，如： 第一层引用 第二层引用 第三层引用 分割线使用三个或以上的-（英文中的减号）或 * 号，推荐使用3个-。 图片 语法：![图片alt](图片地址 &quot;图片title&quot;) 示例： 说明： 图片alt：为图片显示失败时的提示信息 图片地址：绝对url或相对url。其中github的博客中，默认从markdown文件对应的文件夹中寻找，因此，一般把图片放入markdown文件夹中后，使用图片名称.格式或./图片名称.格式。推荐使用前者。支持中文。 图片title：鼠标悬停在图片上时的提示语。可有可无 超链接说明：[超链接名](超链接地址 &quot;超链接title&quot;) 解释： 超链接名：可点击进行跳转的文字 超链接地址：为要跳转的url 超链接title：为鼠标悬停在超链接名上空时的提示语 示例：我的博客 用法：[我的博客](https://unistd68.yancoder.com &quot;小小学渣&quot;) 小技巧：可以使用超链接来访问pdf，markdown文件等，前提是有访问这些文件的权限。（github支持） 无序列表说明：用 - + * 任何一种都可以，和后面的文字之间有一个空格，推荐使用- 示例： 列表1 用法：- 列表1 有序列表说明：数字加点”.”。 备注： 有序列表在列表数量比较大的时候，方便增加或删除列表后的自动排序。因为1,2,3的顺序其实只是表明该行是有序列表。 点号”.”后面有留一个空格。 示例： 列表一 列表二 列表三 用法：1231. 列表一3. 列表二2. 列表三 列表嵌套说明：有序列表和无序列表之间、无序列表之间、有序列表之间的嵌套用法是一样的，只需要在上一级和下一级之间敲三个空格。 示例： （1）demo1：无序列表嵌套有序列表 无序列表一 有序列表一 有序列表二 无序列表二 （2）demo2：有序列表嵌套无序列表 有序列表一 无序列表一 无序列表二 有序列表二 （3）demo3：无序列表嵌套无序列表 无序列表一 无序列表二级标题一 无序列表二级标题二 无序列表二 （4）demo4：有序列表嵌套有序列表 有序列表一 有序列表二级标题一 有序列表二级标题二 有序列表二级标题二 用法：略 表格markdown支持html标签和原生方式 说明： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 用法：12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 流程图说明：github不支持markdown画流程图。 示例：略 用法：略 字体、字号、颜色设置说明：要使用css语法进行设置。 字体：微软雅黑、黑体、宋体 字号：1-10。 颜色：#FF0000（红），推荐使用十六进制颜色值 示例：(有空再把常用的设置都补充完全) 微软雅黑字体黑体3号字4号字红色绿色蓝色 用法：1234567&lt;font face=&quot;微软雅黑&quot; &gt;微软雅黑字体&lt;/font&gt;&lt;font face=&quot;黑体&quot; &gt;黑体&lt;/font&gt;&lt;font size=3 &gt;3号字&lt;/font&gt;&lt;font size=4 &gt;4号字&lt;/font&gt;&lt;font color=#FF0000 &gt;红色&lt;/font&gt;&lt;font color=#008000 &gt;绿色&lt;/font&gt;&lt;font color=#0000FF &gt;蓝色&lt;/font&gt; 背景色设置说明：用到html和css语法。 注意：设置背景色一般要借助table，进行区域染色。 示例： 背景色是 1 orange 背景色2 BlueViolet （1）黑-&gt;灰-&gt;白 #000000#1F1F1F#3B3B3B#575757#7F7F7F#C5C1AA#C7C7C7 （2）蓝 #0000FF#000080#008B8B#00FFFF （3）红-&gt;棕 #EE0000#EE2C2C#DC143C#CD2626#8B0000#B22222 （4）绿 #00FF00#006400#228B22#32CD32#43CD80 （5）黄-&gt;橙 #EEEE00#EE7600#CD6600#FFFF00#EEE685 （6）青-紫 #4B0082#7D26CD#8A2BE2#8968CD#8DEEEE 用法：12&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=orange&gt; 背景色是 1 orange&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=BlueViolet &gt; 背景色2 BlueViolet &lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 数学公式备注：github不支持数学公式 第一个公式： $\\sum_{i=0}^N\\int_{a}^{b}g(t,i)\\text{d}t$ 第二个公式： $$\\sum_{i=0}N\\int_{a}{b}g(t,i)\\text{d}t$$ 换行如果另起一行，只需在当前行结尾加 2 个空格 如果是要起一个新段落，只需要空出一行即可。 复选框在无序列表符号后面加上[]或者[x]代表选中或者未选中情况 12- [x] Markdown - [ ] JavaScript 或者 12+ [x] Markdown + [ ] JavaScript 或者 12* [x] Markdown * [ ] JavaScript 效果： Markdown JavaScript","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://blog.xtcgch.ink/tags/markdown/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"【原理】CentOS下编译动态库和静态库","slug":"20190110-CentOS下编译动态库和静态库","date":"2019-01-10T05:30:18.000Z","updated":"2020-11-22T02:41:12.421Z","comments":true,"path":"CentOS下编译动态库和静态库/","link":"","permalink":"https://blog.xtcgch.ink/CentOS下编译动态库和静态库/","excerpt":"摘要：本篇文章主要简单介绍下，在CentOS7环境下编译动态库和静态库的方法和遇到的坑。","text":"摘要：本篇文章主要简单介绍下，在CentOS7环境下编译动态库和静态库的方法和遇到的坑。 1、脑图 2、开发动态库（1）库代码 dynamicmath.h文件 ： 12345678910111213141516171819#ifndef DYNAMICMATH_H#define DYNAMICMATH_H #include &lt;iostream&gt; class DynamicMath&#123;public: DynamicMath(); ~DynamicMath(); double add(double x, double y); double sub(double x, double y); double mul(double x, double y); double div(double x, double y); void print();&#125;; #endif // DYNAMICMATH_H dynamicmath.cpp文件: 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;dynamicmath.h&quot; DynamicMath::DynamicMath()&#123; &#125; DynamicMath::~DynamicMath()&#123; &#125; double DynamicMath::add(double x, double y)&#123; return x + y;&#125; double DynamicMath::sub(double x, double y)&#123; return x - y;&#125; double DynamicMath::mul(double x, double y)&#123; return x * y;&#125; double DynamicMath::div(double x, double y)&#123; if (y &gt; -0.000001 &amp;&amp; y &lt; 0.000001) &#123; return 0; &#125; else &#123; return x/y; &#125; &#125; void DynamicMath::print()&#123; std::cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; std::endl;&#125; (2)编译 g++ -fPIC -shared -o libdynmath.so dynamicmath.cpp 解释： -fPIC：作用于编译阶段，告诉编译器产生与位置无关代码(Position-Independent Code)。则产生的代码中，没有绝对地址，全部使用相对地址，故而代码可以被加载器加载到内存的任意位置，都可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。 -shared：表示生成动态库文件 因此，生成了libdynmath.so。 （3）使用动态库 前言：项目要引进动态库，必须要包含头文件和动态库。 test.cpp: 123456789101112131415161718#include &quot;dynamicmath.h&quot;#include &lt;iostream&gt; int main() &#123; double x = 10; double y = 2; DynamicMath dm; std::cout &lt;&lt; dm.add(x, y) &lt;&lt; std::endl; std::cout &lt;&lt; dm.sub(x, y) &lt;&lt; std::endl; std::cout &lt;&lt; dm.mul(x, y) &lt;&lt; std::endl; std::cout &lt;&lt; dm.div(x, y) &lt;&lt; std::endl; dm.print(); return 0; &#125; 编译命令： g++ test_d.cpp -L/root/Documents/test/libs/ -ldynmath -I./include 解释： -L：表示动态库的路径，相对路径或者绝对路径。如果未配置这个参数，则默认从系统路径/usr/lib64等位置寻找。 -l：L的小写形式，用于指明要引入的动态库，其中名字不包含前缀’lib’和扩展名’.so’，例如-ldynmath表示libdynmath.so文件 -I：表示头文件所在的文件夹，可相对路径和绝对路径。 重点说明： 编译后会生成a.out文件，但是无法执行，因为找不到依赖的libdynmath.so库，这时候有两种解决方法： 方法一：把libdynmath.so库复制到/usr/lib64/文件夹，然后执行命令ldconfig刷新缓存，再执行./a.out即可 方法二：编辑/etc/ld.so.conf文件，增加库文件所在文件夹的路径，然后执行命令ldconfig刷新缓存，再执行./a.out即可。需要root权限。 方法三（最简单，推荐）：使用shell临时环境变量。export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/root/Documents/test/libs/。 3、开发静态库（1）库代码 mymethod.h文件： 1234567#include &lt;stdio.h&gt;#include &lt;iostream&gt;using namespace std;int add(int a,int b);int myminus(int a,int b); mymethod.cpp文件： 1234567891011#include&lt;mymethod.h&gt;int add(int a,int b)&#123; return a+b;&#125;int myminus(int a,int b)&#123; return a-b;&#125; (2)编译&amp;链接&amp;测试 编译命令： g++ -c mymethod.cpp -o mymethod.o 备注：普通的cpp编译 链接命令： ar -cr libmymethod.a mymethod.o 备注： ar：ar命令可以用来创建、修改库，也可以从库中提出单个模块（所谓的库就是生成的静态库） -c 选项表示 创建一个库。不管库是否存在，都将创建。（不存在则创建，存在则替换） -r 选项表示 将模块插入库，如果库中有对应的模块，那么进行更新。（模块是对源文件.h,.cpp而言） 如果把多个.o文件插入库.a里,只需要在后面用空格分开写出来。格式：ar -cr 静态库libname.a name1.o name2.o 至此，则生成了静态库。 静态库的命名有规则,格式为lib+库名+.a 。 （3）测试 main.cpp文件： 1234567891011#include&quot;mymethod.h&quot;#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;add(5,6)&lt;&lt;endl; cout&lt;&lt;myminus(6,5)&lt;&lt;endl; return 0;&#125; 编译&amp;链接&amp;运行： g++ main.cpp -o main -I ./ -L ./ -lmymethod 说明： -I（i的大写形式）：后面接引用头文件所在文件夹，可相对路径和绝对路径。 -L：后面接静态库文件所在的路径，可相对路径和绝对路径。 -l：后面接静态库的名字。注意，lib+名字+.a组成静态库的库名。 4、总结第一次学习，肯定要先学会抄，抄熟了再学会变通。[手动狗头]","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xtcgch.ink/tags/CentOS/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】Centos7安装mysql8","slug":"20190109-Centos7安装mysql8","date":"2019-01-09T12:48:51.000Z","updated":"2020-11-22T02:41:09.705Z","comments":true,"path":"Centos7安装mysql8/","link":"","permalink":"https://blog.xtcgch.ink/Centos7安装mysql8/","excerpt":"摘要：本文主要介绍在CentOS7下安装MySQL的方法。","text":"摘要：本文主要介绍在CentOS7下安装MySQL的方法。 1、脑图 前言:都是在root权限下进行安装和配置。 [小白]方法一：使用repo源在线安装(1）repo源下载和安装 下载一：https://dev.mysql.com/downloads/repo/yum/ 下载二：wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm 安装：rpm -ivh mysql80-community-release-el7-1.noarch.rpm (2) 安装mysql-server1yum install mysql-server 至此，mysql已经安装完成！可以小高兴一会！ （3）mysql默认安装位置： 头文件： lib包： （4）mysql服务的管理 启动：service mysqld start或systemctl start mysql 重启：service mysqld restart或systemctl restart mysql 关闭：service mysqld stop或systemctl stop mysql （5）设置密码 进入：mysql -uroot,注意，不要使用-p 查看：use mysql; , show tables; , describe user; 配置新密码：update user set password=password(&#39;new password&#39;) where user=&#39;root&#39;;注意，密码要使用password(‘’)函数进行散列化 刷新缓存，让配置立即生效：flush privileges; [进阶]方法二：使用rpm包进行安装 [高]方法三：使用压缩包进行安装 5、总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xtcgch.ink/tags/MySQL/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xtcgch.ink/tags/CentOS/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】Centos7下编译boost","slug":"20190108-Centos7下编译安装Boost","date":"2019-01-08T02:59:19.000Z","updated":"2020-11-22T02:41:06.737Z","comments":true,"path":"Centos7下编译boost/","link":"","permalink":"https://blog.xtcgch.ink/Centos7下编译boost/","excerpt":"摘要：新手入门，保持更新！","text":"摘要：新手入门，保持更新！ 1、脑图 2、boost的下载&amp;解压 官网：https://www.boost.org/ 下载centos版本，如boost_1_69_0.tar.gz 解压：tar -zxvf boost_1_69_0.tar.gz 3、执行bootstrap.sh12cd boost_1_69_0./bootstrap.sh 4、编译：./b2 参数这时没有说编译安装，是因为在非root账户下，编译安装过程中产生的各种库文件放不进去/usr/local/目录下。 默认的编译参数保存在project-config.jam下，可用vim自己查看。 ./b2有诸多的参数可以选择，如下（./b2 –help）： 先使用比较简单的参数：1./b2 --without-python stage debug 编译时间会比较久，编译成功后会生成boost目录（头文件）、stage/lib目录（动态库及静态库）。 5、头文件及库文件拷贝将编译产生的boost目录拷贝至/usr/include/，将stage/lib/下的所有文件拷贝至/usr/lib64/下，如下：12sudo cp -rf boost /usr/includesudo cp -rf stage/lib/* /usr/lib64 6、测试测试文件test.cpp: 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;boost/regex.hpp&gt;int main()&#123; std::string str = &quot;192.168.1.1&quot;; boost::regex expression(&quot;([0-9]+).([0-9]+).([0-9]+)&quot;); boost::smatch what; if(boost::regex_search(str, what, expression)) &#123; std::cout &lt;&lt; what.size() &lt;&lt; std::endl; for(size_t i = 0; i &lt; what.size(); i++) &#123; if(what[i].matched) &#123; std::cout &lt;&lt; what[i] &lt;&lt; std::endl; &#125; &#125; &#125; return 0;&#125; Makefile: 12345678910111213INC_DIR=-I/usr/include/LIB_DIR=-L/usr/lib64/LIB=-lboost_regexCC=g++ -gCFLAGS=-WallEXE=testall: $(CC) $(CFLAGS) $(EXE).cpp -o $(EXE) $(INC_DIR) $(LIB_DIR) $(LIB)clean: rm -rf *.o $(EXE) 7、Boost库“卸载”因为我们只是简单地拷贝头文件和库文件，因此，我们直接删除Boost库头文件和库文件就可以了，如下：12sudo rm -rf /usr/include/boostsudo rm /usr/lib64/*boost*","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xtcgch.ink/tags/CentOS/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】Centos下C++开发常用命令","slug":"20190105-Centos下C++开发常用命令","date":"2019-01-05T02:59:19.000Z","updated":"2020-11-22T02:51:27.740Z","comments":true,"path":"Centos下C++开发常用命令/","link":"","permalink":"https://blog.xtcgch.ink/Centos下C++开发常用命令/","excerpt":"摘要：新手入门，保持更新！","text":"摘要：新手入门，保持更新！ 1、脑图 本人是在Centos6.4 64bit系统上进行测试的，GCC版本是4.4.7。 2、编译命令2.1 引进外部头文件2.1.1 方法一 在编译时添加命令 -I(i的大写) 2.1.2 方法二在环境变量中进行设置(临时) （1）gcc中查找路径12C_INCLUDE_PATH=/usr/include/ export C_INCLUDE_PATH (2)g++的查找路径12CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/include/ export CPLUS_INCLUDE_PATH 2.2 引进外部静态/动态库2.2.1 动态库（1）方法一：添加编译命令 库目录：-L/lib/库文件：-l/libsoci_mysql ,代表着libsoci_mysql.so库 （2）方法二：添加环境变量 12LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/MyLib export LD_LIBRARY_PATH 2.2.2 静态库（1）方法一：添加编译命令 库目录：-L/lib/ -static库文件：-l/libsoci_mysql ,代表着libsoci_mysql.so库 （2）方法二：添加环境变量 12LIBRARY_PATH=$LIBRARY_PATH:/MyLib export LIBRARY_PATH 2.3 使用C++11标准进行编译1-std=c++11（字母都是小写形式） 3 调试命令3.1 strings命令：查看系统glibc支持的版本1234567891011121314151617181920212223242526272829303132333435363738[root@lzv6 c++]# strings /usr/lib64/libstdc++.so.6 | grep GLIBCGLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBC_2.2.5GLIBC_2.3GLIBC_2.4GLIBC_2.3.2GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH[root@lzv6 c++]# strings /lib64/libc.so.6 | grep GLIBC_GLIBC_2.2.5GLIBC_2.2.6GLIBC_2.3GLIBC_2.3.2GLIBC_2.3.3GLIBC_2.3.4GLIBC_2.4GLIBC_2.5GLIBC_2.6GLIBC_2.7GLIBC_2.8GLIBC_2.9GLIBC_2.10GLIBC_2.11GLIBC_2.12GLIBC_PRIVATE 3.2 g++ -E选项：预处理源文件12345[root@lzv6 c++]# g++ -E -o vec2.cpp vec.cpp [root@lzv6 c++]# wc vec.cpp vec2.cpp 33 71 557 vec.cpp 20958 45683 534803 vec2.cpp 20991 45754 535360 总用量 上面每行分别代表行数、单次数、字节数。 从这里也可以看出引入多余头文件是件多么可怕的事情，多引入一个头文件，就要预处理N行。你可以试着#include &lt;stdio.h&gt;,然后再看看增加了多少行。 3.3 ldd命令：显示目标文件的依赖库1234567891011121314151617181920212223242526272829303132333435363738394041[root@lzv6 c++]# ldd vec linux-vdso.so.1 =&gt; (0x00007fff8fbff000) libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003317800000) libm.so.6 =&gt; /lib64/libm.so.6 (0x000000309ca00000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003317400000) libc.so.6 =&gt; /lib64/libc.so.6 (0x000000309ce00000) /lib64/ld-linux-x86-64.so.2 (0x000000309c600000) [root@lzv6 c++]# ldd -v vec // -v 表示 打印所有信息，例如包括符号的版本信息 linux-vdso.so.1 =&gt; (0x00007fff585ff000) libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x0000003317800000) libm.so.6 =&gt; /lib64/libm.so.6 (0x000000309ca00000) libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x0000003317400000) libc.so.6 =&gt; /lib64/libc.so.6 (0x000000309ce00000) /lib64/ld-linux-x86-64.so.2 (0x000000309c600000) Version information: ./vec: libgcc_s.so.1 (GCC_3.0) =&gt; /lib64/libgcc_s.so.1 libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6 libstdc++.so.6 (CXXABI_1.3) =&gt; /usr/lib64/libstdc++.so.6 libstdc++.so.6 (GLIBCXX_3.4) =&gt; /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6: libm.so.6 (GLIBC_2.2.5) =&gt; /lib64/libm.so.6 ld-linux-x86-64.so.2 (GLIBC_2.3) =&gt; /lib64/ld-linux-x86-64.so.2 libgcc_s.so.1 (GCC_4.2.0) =&gt; /lib64/libgcc_s.so.1 libgcc_s.so.1 (GCC_3.3) =&gt; /lib64/libgcc_s.so.1 libgcc_s.so.1 (GCC_3.0) =&gt; /lib64/libgcc_s.so.1 libc.so.6 (GLIBC_2.4) =&gt; /lib64/libc.so.6 libc.so.6 (GLIBC_2.3) =&gt; /lib64/libc.so.6 libc.so.6 (GLIBC_2.3.2) =&gt; /lib64/libc.so.6 libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6 /lib64/libm.so.6: libc.so.6 (GLIBC_PRIVATE) =&gt; /lib64/libc.so.6 libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6 /lib64/libgcc_s.so.1: libc.so.6 (GLIBC_2.4) =&gt; /lib64/libc.so.6 libc.so.6 (GLIBC_2.2.5) =&gt; /lib64/libc.so.6 /lib64/libc.so.6: ld-linux-x86-64.so.2 (GLIBC_PRIVATE) =&gt; /lib64/ld-linux-x86-64.so.2 ld-linux-x86-64.so.2 (GLIBC_2.3) =&gt; /lib64/ld-linux-x86-64.so.2 3.4 objdump命令：查看目标文件的动态引用符号表123456789101112131415161718192021222324[root@lzv6 c++]# objdump -T vecvec: file format elf64-x86-64DYNAMIC SYMBOL TABLE:0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZSt20__throw_length_errorPKc0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZNSolsEi0000000000000000 w D *UND* 0000000000000000 __gmon_start__0000000000000000 w D *UND* 0000000000000000 _Jv_RegisterClasses0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZdlPv0000000000000000 DF *UND* 0000000000000000 CXXABI_1.3 __cxa_rethrow0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZNSt8ios_base4InitC1Ev0000000000000000 DF *UND* 0000000000000000 GLIBC_2.2.5 __libc_start_main0000000000000000 DF *UND* 0000000000000000 GLIBC_2.2.5 __cxa_atexit0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc0000000000000000 DF *UND* 0000000000000000 GLIBC_2.2.5 memmove0000000000000000 DF *UND* 0000000000000000 CXXABI_1.3 __cxa_end_catch0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZSt17__throw_bad_allocv0000000000000000 DF *UND* 0000000000000000 CXXABI_1.3 __cxa_begin_catch0000000000000000 DF *UND* 0000000000000000 GLIBCXX_3.4 _Znwm0000000000000000 DF *UND* 0000000000000000 GCC_3.0 _Unwind_Resume0000000000400910 DF *UND* 0000000000000000 GLIBCXX_3.4 _ZNSt8ios_base4InitD1Ev00000000006026e0 g DO .bss 0000000000000110 GLIBCXX_3.4 _ZSt4cout0000000000400970 DF *UND* 0000000000000000 CXXABI_1.3 __gxx_personality_v0 – 3.4 objdump命令：查看目标文件引用了GLIBC的哪些版本中的哪些函数12341 [root@lzv6 c++]# objdump -T vec | grep GLIBC_2 0000000000000000 DF *UND* 0000000000000000 GLIBC_2.2.5 __libc_start_main3 0000000000000000 DF *UND* 0000000000000000 GLIBC_2.2.5 __cxa_atexit4 0000000000000000 DF *UND* 0000000000000000 GLIBC_2.2.5 memmove 3.6 nm命令：显示vec程序中使用的函数123451 [root@lzv6 c++]# nm -o vec | grep print2 vec:0000000000400c50 t _GLOBAL__I__Z9print_vecRKSt6vectorIiSaIiEE3 vec:0000000000400b0c T _Z9print_inti4 vec:0000000000400b42 T _Z9print_strPc5 vec:0000000000400a84 T _Z9print_vecRKSt6vectorIiSaIiEE 3.7 c++filt命令：显示未重整(unmangled)的原函数声明123456789101112[root@lzv6 c++]# nm vec | grep &apos;print&apos;00000000004009e0 t _GLOBAL__I__Z9print_vecRKSt6vectorIiSaIiEE0000000000400b00 T _Z9print_inti0000000000400a90 T _Z9print_strPc0000000000400a10 T _Z9print_vecRKSt6vectorIiSaIiEE[root@lzv6 c++]# c++filt _Z9print_intiprint_int(int)[root@lzv6 c++]# nm vec | grep print | c++filt00000000004009e0 t global constructors keyed to _Z9print_vecRKSt6vectorIiSaIiEE0000000000400b00 T print_int(int)0000000000400a90 T print_str(char*)0000000000400a10 T print_vec(std::vector&lt;int, std::allocator&lt;int&gt; &gt; const&amp;) 3.8 nm命令：显示目标文件的所有符号清单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117[root@lzv6 c++]# nm -o vecvec:0000000000602460 d _DYNAMICvec:0000000000602628 d _GLOBAL_OFFSET_TABLE_vec:0000000000400c50 t _GLOBAL__I__Z9print_vecRKSt6vectorIiSaIiEEvec:00000000004019b8 R _IO_stdin_usedvec: w _Jv_RegisterClassesvec: U _Unwind_Resume@@GCC_3.0vec:0000000000400c10 t _Z41__static_initialization_and_destruction_0iivec:0000000000400b0c T _Z9print_intivec:0000000000400b42 T _Z9print_strPcvec:0000000000400a84 T _Z9print_vecRKSt6vectorIiSaIiEEvec:0000000000401504 W _ZN9__gnu_cxx13new_allocatorIiE10deallocateEPimvec:00000000004014b6 W _ZN9__gnu_cxx13new_allocatorIiE7destroyEPivec:00000000004015e8 W _ZN9__gnu_cxx13new_allocatorIiE8allocateEmPKvvec:0000000000400eae W _ZN9__gnu_cxx13new_allocatorIiE9constructEPiRKivec:0000000000401664 W _ZN9__gnu_cxx13new_allocatorIiEC1Evvec:0000000000401664 W _ZN9__gnu_cxx13new_allocatorIiEC2Evvec:00000000004014fa W _ZN9__gnu_cxx13new_allocatorIiED1Evvec:00000000004014fa W _ZN9__gnu_cxx13new_allocatorIiED2Evvec:00000000004014c4 W _ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEC1ERKS1_vec:00000000004014c4 W _ZN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEC2ERKS1_vec:00000000004013fb W _ZN9__gnu_cxxmiIPiSt6vectorIiSaIiEEEENS_17__normal_iteratorIT_T0_E15difference_typeERKS8_SB_vec:00000000004016bc W _ZNK9__gnu_cxx13new_allocatorIiE8max_sizeEvvec:00000000004012a6 W _ZNK9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEE4baseEvvec:00000000004012fa W _ZNK9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEdeEvvec:00000000004016ae W _ZNKSt12_Vector_baseIiSaIiEE19_M_get_Tp_allocatorEvvec:000000000040130c W _ZNKSt6vectorIiSaIiEE12_M_check_lenEmPKcvec:0000000000400c78 W _ZNKSt6vectorIiSaIiEE4sizeEvvec:000000000040159a W _ZNKSt6vectorIiSaIiEE8max_sizeEvvec:0000000000400ca2 W _ZNKSt6vectorIiSaIiEEixEmvec:00000000004014e0 W _ZNSaIiEC1Evvec:00000000004014e0 W _ZNSaIiEC2Evvec:0000000000401232 W _ZNSaIiED1Evvec:0000000000401232 W _ZNSaIiED2Evvec: U _ZNSolsEi@@GLIBCXX_3.4vec:0000000000401861 W _ZNSt11__copy_moveILb0ELb1ESt26random_access_iterator_tagE8__copy_mIiEEPT_PKS3_S6_S4_vec:0000000000401526 W _ZNSt12_Destroy_auxILb1EE9__destroyIPiEEvT_S3_vec:0000000000401442 W _ZNSt12_Vector_baseIiSaIiEE11_M_allocateEmvec:00000000004011f4 W _ZNSt12_Vector_baseIiSaIiEE12_Vector_implC1Evvec:00000000004011f4 W _ZNSt12_Vector_baseIiSaIiEE12_Vector_implC2Evvec:0000000000400dc4 W _ZNSt12_Vector_baseIiSaIiEE12_Vector_implD1Evvec:0000000000400dc4 W _ZNSt12_Vector_baseIiSaIiEE12_Vector_implD2Evvec:000000000040124c W _ZNSt12_Vector_baseIiSaIiEE13_M_deallocateEPimvec:0000000000400e76 W _ZNSt12_Vector_baseIiSaIiEE19_M_get_Tp_allocatorEvvec:0000000000400dde W _ZNSt12_Vector_baseIiSaIiEEC1Evvec:0000000000400dde W _ZNSt12_Vector_baseIiSaIiEEC2Evvec:0000000000400df8 W _ZNSt12_Vector_baseIiSaIiEED1Evvec:0000000000400df8 W _ZNSt12_Vector_baseIiSaIiEED2Evvec:0000000000401534 W _ZNSt12__miter_baseIPiLb0EE3__bES0_vec:000000000040166e W _ZNSt12__niter_baseIPiLb0EE3__bES0_vec:00000000004016fd W _ZNSt20__copy_move_backwardILb0ELb1ESt26random_access_iterator_tagE13__copy_move_bIiEEPT_PKS3_S6_S4_vec:0000000000401765 W _ZNSt20__uninitialized_copyILb1EE18uninitialized_copyIPiS2_EET0_T_S4_S3_vec:0000000000400ee6 W _ZNSt6vectorIiSaIiEE13_M_insert_auxEN9__gnu_cxx17__normal_iteratorIPiS1_EERKivec:00000000004011ca W _ZNSt6vectorIiSaIiEE3endEvvec:00000000004013d6 W _ZNSt6vectorIiSaIiEE5beginEvvec:0000000000400d4a W _ZNSt6vectorIiSaIiEE9push_backERKivec:0000000000400cc2 W _ZNSt6vectorIiSaIiEEC1Evvec:0000000000400cc2 W _ZNSt6vectorIiSaIiEEC2Evvec:0000000000400cdc W _ZNSt6vectorIiSaIiEED1Evvec:0000000000400cdc W _ZNSt6vectorIiSaIiEED2Evvec: U _ZNSt8ios_base4InitC1Ev@@GLIBCXX_3.4vec: U _ZNSt8ios_base4InitD1Ev@@GLIBCXX_3.4vec:0000000000401830 W _ZSt13__copy_move_aILb0EPiS0_ET1_T0_S2_S1_vec:00000000004012b4 W _ZSt13copy_backwardIPiS0_ET0_T_S2_S1_vec:00000000004017d8 W _ZSt14__copy_move_a2ILb0EPiS0_ET1_T0_S2_S1_vec: U _ZSt17__throw_bad_allocv@@GLIBCXX_3.4vec:00000000004016d0 W _ZSt18uninitialized_copyIPiS0_ET0_T_S2_S1_vec: U _ZSt20__throw_length_errorPKc@@GLIBCXX_3.4vec:000000000040167c W _ZSt22__copy_move_backward_aILb0EPiS0_ET1_T0_S2_S1_vec:0000000000401633 W _ZSt22__uninitialized_copy_aIPiS0_iET0_T_S2_S1_RSaIT1_Evec:000000000040147a W _ZSt22__uninitialized_move_aIPiS0_SaIiEET0_T_S3_S2_RT1_vec:0000000000401542 W _ZSt23__copy_move_backward_a2ILb0EPiS0_ET1_T0_S2_S1_vec:00000000004015bc W _ZSt3maxImERKT_S2_S2_vec:0000000000401792 W _ZSt4copyIPiS0_ET0_T_S2_S1_vec:00000000006026e0 B _ZSt4cout@@GLIBCXX_3.4vec:0000000000401280 W _ZSt8_DestroyIPiEvT_S1_vec:0000000000400e84 W _ZSt8_DestroyIPiiEvT_S1_RSaIT0_Evec:0000000000602800 b _ZStL8__ioinitvec: U _ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@@GLIBCXX_3.4vec: U _ZdlPv@@GLIBCXX_3.4vec: U _Znwm@@GLIBCXX_3.4vec:0000000000400c65 W _ZnwmPvvec:0000000000602440 d __CTOR_END__vec:0000000000602430 d __CTOR_LIST__vec:0000000000602450 D __DTOR_END__vec:0000000000602448 d __DTOR_LIST__vec:00000000004023d0 r __FRAME_END__vec:0000000000602458 d __JCR_END__vec:0000000000602458 d __JCR_LIST__vec:00000000006026c4 A __bss_startvec: U __cxa_atexit@@GLIBC_2.2.5vec: U __cxa_begin_catch@@CXXABI_1.3vec: U __cxa_end_catch@@CXXABI_1.3vec: U __cxa_rethrow@@CXXABI_1.3vec:00000000006026c0 D __data_startvec:0000000000401970 t __do_global_ctors_auxvec:00000000004009f0 t __do_global_dtors_auxvec:00000000004019c0 R __dso_handlevec: w __gmon_start__vec: U __gxx_personality_v0@@CXXABI_1.3vec:000000000060242c d __init_array_endvec:000000000060242c d __init_array_startvec:00000000004018d0 T __libc_csu_finivec:00000000004018e0 T __libc_csu_initvec: U __libc_start_main@@GLIBC_2.2.5vec:00000000006026c4 A _edatavec:0000000000602808 A _endvec:00000000004019a8 T _finivec:0000000000400878 T _initvec:00000000004009a0 T _startvec:00000000004009cc t call_gmon_startvec:00000000006027f0 b completed.6349vec:00000000006026c0 W data_startvec:00000000006027f8 b dtor_idx.6351vec:0000000000400a60 t frame_dummyvec:0000000000400b7b T mainvec: U memmove@@GLIBC_2.2.5 3.9 strace命令：显示在预处理的时候读取的所有头文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154[root@lzv6 c++]# strace -f -e open cpp vec.cpp -o /dev/null 2&gt;&amp;1 | grep -v ENOENT | awk &apos;&#123;print $3&#125;&apos; ======attachedopen(&quot;/etc/ld.so.cache&quot;,open(&quot;/usr/lib64/libmpfr.so.1&quot;,open(&quot;/usr/lib64/libgmp.so.3&quot;,open(&quot;/lib64/libdl.so.2&quot;,open(&quot;/lib64/libc.so.6&quot;,open(&quot;/usr/lib/locale/locale-archive&quot;,open(&quot;/usr/share/locale/locale.alias&quot;,open(&quot;/usr/share/locale/zh_CN/LC_MESSAGES/gcc.mo&quot;,open(&quot;/usr/lib64/gconv/gconv-modules.cache&quot;,open(&quot;/proc/meminfo&quot;,open(&quot;/proc/meminfo&quot;,open(&quot;/proc/meminfo&quot;,open(&quot;/dev/null&quot;,open(&quot;vec.cpp&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/iostream&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/c++config.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/os_defines.h&quot;,open(&quot;/usr/include/features.h&quot;,open(&quot;/usr/include/sys/cdefs.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/include/gnu/stubs.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/include/gnu/stubs-64.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/cpu_defines.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ostream&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ios&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/iosfwd&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stringfwd.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/postypes.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cwchar&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/wchar.h&quot;,open(&quot;/usr/include/stdio.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stdarg.h&quot;,open(&quot;/usr/include/bits/wchar.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/xlocale.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/exception&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/char_traits.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_algobase.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/functexcept.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/exception_defines.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/cpp_type_traits.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ext/type_traits.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ext/numeric_traits.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_pair.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/move.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/concept_check.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_iterator_base_types.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_iterator_base_funcs.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_iterator.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/debug/debug.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cwchar&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/wchar.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/localefwd.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/c++locale.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/clocale&quot;,open(&quot;/usr/include/locale.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/bits/locale.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cctype&quot;,open(&quot;/usr/include/ctype.h&quot;,open(&quot;/usr/include/bits/types.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/include/bits/typesizes.h&quot;,open(&quot;/usr/include/endian.h&quot;,open(&quot;/usr/include/bits/endian.h&quot;,open(&quot;/usr/include/bits/byteswap.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/ios_base.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ext/atomicity.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/gthr.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/gthr-default.h&quot;,open(&quot;/usr/include/pthread.h&quot;,open(&quot;/usr/include/sched.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/time.h&quot;,open(&quot;/usr/include/bits/sched.h&quot;,open(&quot;/usr/include/time.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/bits/time.h&quot;,open(&quot;/usr/include/bits/pthreadtypes.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/include/bits/setjmp.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/include/unistd.h&quot;,open(&quot;/usr/include/bits/posix_opt.h&quot;,open(&quot;/usr/include/bits/environments.h&quot;,open(&quot;/usr/include/bits/wordsize.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/include/bits/confname.h&quot;,open(&quot;/usr/include/getopt.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/atomic_word.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/locale_classes.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/string&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/allocator.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/c++allocator.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/ext/new_allocator.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/new&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cstddef&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/include/stddef.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/ostream_insert.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cxxabi-forced.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_function.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/backward/binders.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/basic_string.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/initializer_list&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/basic_string.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/locale_classes.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/streambuf&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/streambuf.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/basic_ios.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/locale_facets.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cwctype&quot;,open(&quot;/usr/include/wctype.h&quot;,open(&quot;/usr/include/wchar.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/cctype&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/ctype_base.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/streambuf_iterator.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/x86_64-redhat-linux/bits/ctype_inline.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/locale_facets.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/basic_ios.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/ostream.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/istream&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/istream.tcc&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/vector&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_construct.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_uninitialized.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_vector.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/stl_bvector.h&quot;,open(&quot;/usr/lib/gcc/x86_64-redhat-linux/4.4.7/../../../../include/c++/4.4.7/bits/vector.tcc&quot;,detached(Child 测试代码： 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;void print_vec(const std::vector&lt;int&gt;&amp; vec)&#123; std::cout &lt;&lt; &quot;print vec : &quot;; size_t size = vec.size(); for(size_t i = 0; i&lt;size; i++) std::cout &lt;&lt; vec[i] &lt;&lt; &quot;\\t&quot;; std::cout &lt;&lt; &quot;\\n&quot;;&#125;void print_int(int i)&#123; std::cout&lt;&lt;&quot;print_int : &quot; &lt;&lt; i &lt;&lt; &quot;\\n&quot;; &#125;void print_str(char* str)&#123; std::cout&lt;&lt;&quot;print_str : &quot; &lt;&lt; str &lt;&lt; &quot;\\n&quot;; &#125;int main()&#123; std::vector&lt;int&gt; vec; vec.push_back(1); print_vec(vec); print_int(vec.size()); print_str(&quot;hello world!&quot;); return 0;&#125;//编译：//g++ -o vec vec.cpp","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xtcgch.ink/tags/CentOS/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】平衡树","slug":"20181216-平衡树","date":"2018-12-16T02:28:27.000Z","updated":"2020-11-22T02:41:00.800Z","comments":true,"path":"平衡树/","link":"","permalink":"https://blog.xtcgch.ink/平衡树/","excerpt":"摘要：平衡树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。","text":"摘要：平衡树是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 1、脑图 2、简介平衡树，即平衡二叉树（Balanced Binary Tree），具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 最小二叉平衡树的节点的公式如下 F(n)=F(n-1)+F(n-2)+1 这个类似于一个递归的数列，可以参考Fibonacci数列，1是根节点，F(n-1)是左子树的节点数量，F(n-2)是右子树的节点数量。 3、旋转 3.1 LL（左左） X指的是一颗子树 y和z都是一个节点 K2是不符合平衡的节点 K1,K2,和子树X的位置分布为左 、左，即LL 代码实现： 12345678910111213static Node* left_left_rotation(AVLTree k2)&#123; AVLTree k1; k1 = k2-&gt;left; k2-&gt;left = k1-&gt;right; k1-&gt;right = k2; k2-&gt;height = MAX( HEIGHT(k2-&gt;left), HEIGHT(k2-&gt;right)) + 1; k1-&gt;height = MAX( HEIGHT(k1-&gt;left), k2-&gt;height) + 1; return k1;&#125; 3.2 RR（右右） Z指的是一颗子树 y和x都是一个节点 K1是不符合平衡的节点 K1,K2,和Z子树的位置分布为右、右，即RR 代码实现： 12345678910111213static Node* right_right_rotation(AVLTree k1)&#123; AVLTree k2; k2 = k1-&gt;right; k1-&gt;right = k2-&gt;left; k2-&gt;left = k1; k1-&gt;height = MAX( HEIGHT(k1-&gt;left), HEIGHT(k1-&gt;right)) + 1; k2-&gt;height = MAX( HEIGHT(k2-&gt;right), k1-&gt;height) + 1; return k2;&#125; 3.3 LR（RR+LL） A,B,C,D都是一个节点 K3是不符合平衡的节点 K1,K2,K3的位置感为左，右，即LR分布 123456static Node* left_right_rotation(AVLTree k3)&#123; k3-&gt;left = right_right_rotation(k3-&gt;left); return left_left_rotation(k3);&#125; 3.4 RL（LL+RR） A,B,C,D都是一个节点 K1是不符合平衡的节点 K1,K2,K3的位置分布为右，左，即RL 123456static Node* right_left_rotation(AVLTree k1)&#123; k1-&gt;right = left_left_rotation(k1-&gt;right); return right_right_rotation(k1);&#125; 4、例子依次添加”3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9” 到AVL树中，过程如下。 （1）添加3,2 （2）添加1 （3）添加4 （4）添加5 （5）添加6 （6）添加7 （7）添加16 （8）添加15—好像是RL，不是RR （9）添加14 （10）添加13 （11）添加12 （12）添加11 （13）添加10 （14）添加8 （15）添加9","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog.xtcgch.ink/tags/数据结构/"},{"name":"树","slug":"树","permalink":"https://blog.xtcgch.ink/tags/树/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】SQL语法","slug":"20181214-SQL语法","date":"2018-12-14T04:08:14.000Z","updated":"2020-11-22T02:40:58.316Z","comments":true,"path":"SQL语法/","link":"","permalink":"https://blog.xtcgch.ink/SQL语法/","excerpt":"摘要：SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的私有扩展！","text":"摘要：SQL 是一门 ANSI 的标准计算机语言，用来访问和操作数据库系统。SQL 语句用于取回和更新数据库中的数据。SQL 可与数据库程序协同工作，比如 MS Access、DB2、Informix、MS SQL Server、Oracle、Sybase 以及其他数据库系统。除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的私有扩展！ 1、脑图 2、分类2.1 DDL数据定义语言DDL用来创建数据库中的各种对象—–表、视图、 索引、同义词、聚簇等如： CREATE TABLE/VIEW/INDEX/SYN/CLUSTER | | | | | 表 视图 索引 同义词 簇 2.2 DML数据操纵语言DML主要有三种形式： 1) 插入：INSERT 2) 更新：UPDATE 3) 删除：DELETE 2.3 DQL数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE 子句组成的查询块。 3、关键字3.1 DISTINCT（1）说明 在表中，一个列可能会包含多个重复值，DISTINCT 关键词用于返回唯一不同的值。 （2）用法 SELECT DISTINCT 列名称 FROM 表名称 （3）例子 SELECT DISTINCT Company FROM Orders 3.2 TOP（1）说明 SELECT TOP 子句用于规定要返回的记录的数目。可筛选指定数目或比例。注意：并非所有的数据库系统都支持 SELECT TOP 语句。 MySQL 支持 LIMIT 语句来选取指定的条数数据， Oracle 可以使用 ROWNUM 来选取。 （2）用法 MySQL：SELECT column_name(s) FROM table_name LIMIT number Oracle:SELECT column_name(s) FROM table_name WHERE ROWNUM &lt;= number （3）例子 SELECT * FROM Persons LIMIT 5 SELECT * FROM Persons WHERE ROWNUM &lt;= 5 SELECT TOP 50 PERCENT * FROM Persons 3.3 LIKE（1）说明 LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。 （2）用法 SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern; （3）例子 SELECT * FROM Websites WHERE name LIKE ‘G%’;- 3.4 IN（1）说明 IN 操作符允许在 WHERE 子句中规定多个值。 （2）用法 SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,…); （3）例子 SELECT * FROM Websites WHERE name IN (‘Google’,’菜鸟教程’); （4）in 与 = 相同点：均在WHERE中使用作为筛选条件之一、均是等于的含义 不同点：IN可以规定多个值，等于规定一个值 3.5 BETWEEN（1）说明 BETWEEN 操作符用于选取介于两个值之间的数据范围内的值。 （2）用法 SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2; （3）例子 SELECT * FROM Websites WHERE alexa BETWEEN 1 AND 20; SELECT * FROM Websites WHERE alexa NOT BETWEEN 1 AND 20; 3.6 Alias（1）说明 使用列别名和表别名来简化列名和表名。 （2）用法 SELECT column_name AS alias_name FROM table_name; SELECT column_name(s) FROM table_name AS alias_name; （3）例子 SELECT name AS n, country AS c FROM Websites; SELECT w.name, w.url, a.count, a.date FROM Websites AS w, access_log AS a WHERE a.site_id=w.id and w.name=”菜鸟教程”; 3.7 JOIN（1）说明 SQL JOIN 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。 （2）用法 SELECT Websites.id, Websites.name, access_log.count, access_log.date FROM Websites INNER JOIN access_log ON Websites.id=access_log.site_id; （3）例子 （4）区别 INNER JOIN：如果表中有至少一个匹配，则返回行 LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行 FULL JOIN：只要其中一个表中存在匹配，则返回行 3.8 INNER JOIN（1）说明 INNER JOIN 关键字在表中存在至少一个匹配时返回行。 （2）用法 SELECT column_name(s) FROM table1 INNER JOIN table2 ON table1.column_name=table2.column_name; （3）例子 SELECT Websites.name, access_log.count, access_log.date FROM Websites INNER JOIN access_log ON Websites.id=access_log.site_id ORDER BY access_log.count; 3.9 LEFT JOIN（1）说明 LEFT JOIN 关键字从左表（table1）返回所有的行，即使右表（table2）中没有匹配。如果右表中没有匹配，则结果为 NULL。 （2）用法 SELECT column_name(s) FROM table1 LEFT JOIN table2 ON table1.column_name=table2.column_name; （3）例子 SELECT Websites.name, access_log.count, access_log.date FROM Websites LEFT JOIN access_log ON Websites.id=access_log.site_id ORDER BY access_log.count DESC; 3.10 RIGHT JOIN（1）说明 RIGHT JOIN 关键字从右表（table2）返回所有的行，即使左表（table1）中没有匹配。如果左表中没有匹配，则结果为 NULL。 （2）用法 SELECT column_name(s) FROM table1 RIGHT JOIN table2 ON table1.column_name=table2.column_name; （3）例子 SELECT Websites.name, access_log.count, access_log.date FROM access_log RIGHT JOIN Websites ON access_log.site_id=Websites.id ORDER BY access_log.count DESC; 3.11 FULL JOIN（1）说明 FULL OUTER JOIN 关键字只要左表（table1）和右表（table2）其中一个表中存在匹配，则返回行. FULL OUTER JOIN 关键字结合了 LEFT JOIN 和 RIGHT JOIN 的结果。 （2）用法 SELECT column_name(s) FROM table1 FULL OUTER JOIN table2 ON table1.column_name=table2.column_name; （3）例子 SELECT Websites.name, access_log.count, access_log.date FROM Websites FULL OUTER JOIN access_log ON Websites.id=access_log.site_idORDER BY access_log.count DESC; 3.12 UNION（1）说明 SQL UNION 操作符合并两个或多个 SELECT 语句的结果。 请注意，UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。 （2）用法 SELECT column_name(s) FROM table1 UNION SELECT column_name(s) FROM table2; （3）例子 SELECT country FROM Websites UNION SELECT country FROM apps ORDER BY country; 3.13 SELECT INTO（1）说明 通过 SQL，您可以从一个表复制信息到另一个表。 SELECT INTO 语句从一个表复制数据，然后把数据插入到另一个新表中。 （2）用法 SELECT * INTO newtable [IN externaldb] FROM table1; SELECT column_name(s) INTO newtable [IN externaldb] FROM table1; （3）例子 SELECT * INTO WebsitesBackup2016 FROM Websites; SELECT name, url INTO WebsitesBackup2016 FROM Websites; 3.14 NULL（1）说明 NULL 值的处理方式与其他值不同。 NULL 用作未知的或不适用的值的占位符。 （2）用法 （3）例子 IS NOT NULL:SELECT LastName,FirstName,Address FROM Persons WHERE Address IS NOT NULL IS NULL: SELECT LastName,FirstName,Address FROM Persons WHERE Address IS NULL 4、函数4.1 时间函数（1）用法 NOW(): CURDATE()： CURTIME()： DATE()： EXTRACT()： DATE_ADD()： DATE_SUB()： DATEDIFF()： DATE_FORMAT()： （2）例子 4.2 AVG()（1）说明 AVG() 函数返回数值列的平均值。 （2）用法 SELECT AVG(column_name) FROM table_name （3）例子 SELECT AVG(count) AS CountAverage FROM access_log; 4.3 COUNT()（1）说明 COUNT() 函数返回匹配指定条件的行数。 （2）用法 SELECT COUNT(column_name) FROM table_name; SELECT COUNT( * ) FROM table_name; SELECT COUNT(DISTINCT column_name) FROM table_name; （3）例子 SELECT COUNT(count) AS nums FROM access_log WHERE site_id=3; SELECT COUNT( * ) AS nums FROM access_log; SELECT COUNT(DISTINCT site_id) AS nums FROM access_log; 4.4 FIRST()（1）说明 FIRST() 函数返回指定的列中第一个记录的值。注意：只有 MS Access 支持 FIRST() 函数 （2）用法 SELECT column_name FROM table_name ORDER BY column_name ASC LIMIT 1; SELECT column_name FROM table_name ORDER BY column_name ASC WHERE ROWNUM &lt;=1 （3）例子 SELECT name FROM Websites ORDER BY id ASC LIMIT 1; SELECT name FROM Websites ORDER BY id ASC WHERE ROWNUM &lt;=1; 4.5 LAST()（1）说明 LAST() 函数返回指定的列中最后一个记录的值。注意：只有 MS Access 支持 LAST() 函数。 （2）用法 SELECT column_name FROM table_name ORDER BY column_name DESC LIMIT 1; SELECT column_name FROM table_name ORDER BY column_name DESC WHERE ROWNUM &lt;=1; （3）例子 SELECT name FROM Websites ORDER BY id DESC LIMIT 1; SELECT name FROM Websites ORDER BY id DESC WHERE ROWNUM &lt;=1; 4.6 MAX()（1）说明 MAX() 函数返回指定列的最大值。 （2）用法 SELECT MAX(column_name) FROM table_name; （3）例子 SELECT MAX(alexa) AS max_alexa FROM Websites; 4.7 MIN()（1）说明 MIN() 函数返回指定列的最小值。 （2）用法 SELECT MIN(column_name) FROM table_name; （3）例子 SELECT MIN(alexa) AS min_alexa FROM Websites; 4.8 值为NULL的判断（1）说明 （2）用法 IFNULL() COALESCE() NVL() （3）例子 SELECT ProductName,UnitPrice * (UnitsInStock+IFNULL(UnitsOnOrder,0)) FROM Products SELECT ProductName,UnitPrice * (UnitsInStock+COALESCE(UnitsOnOrder,0)) FROM Products SELECT ProductName,UnitPrice * (UnitsInStock+NVL(UnitsOnOrder,0)) FROM Products 4.9 SUM()（1）说明 SUM() 函数返回数值列的总数。 （2）用法 SELECT SUM(column_name) FROM table_name;- （3）例子 SELECT SUM(count) AS nums FROM access_log;- 4.10 HAVING（1）说明 在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。 HAVING 子句可以让我们筛选分组后的各组数据。 （2）用法 SELECT column_name, aggregate_function(column_name) FROM table_name WHERE column_name operator value GROUP BY column_name HAVING aggregate_function(column_name) operator value; （3）例子 SELECT Websites.name, Websites.url, SUM(access_log.count) AS nums FROM (access_log INNER JOIN Websites ON access_log.site_id=Websites.id) GROUP BY Websites.name HAVING SUM(access_log.count) &gt; 200; 4.11 UCASE()（1）说明 UCASE() 函数把字段的值转换为大写。 （2）用法 SELECT UCASE(column_name) FROM table_name; （3）例子 SELECT UCASE(name) AS site_title, url FROM Websites; 4.12 LCASE()（1）说明 LCASE() 函数把字段的值转换为小写。 （2）用法 SELECT LCASE(column_name) FROM table_name; （3）例子 SELECT LCASE(name) AS site_title, url FROM Websites; 4.13 MID()（1）说明 MID() 函数用于从文本字段中提取字符。 （2）用法 SELECT MID(column_name,start[,length]) FROM table_name; （3）例子 SELECT MID(name,1,4) AS ShortTitle FROM Websites; 4.14 LEN()（1）说明 LEN() 函数返回文本字段中值的长度。 （2）用法 SELECT LEN(column_name) FROM table_name; （3）例子 SELECT name, LENGTH(url) as LengthOfURL FROM Websites; 4.15 ROUND()（1）说明 ROUND 函数用于把数值字段舍入为指定的小数位数。 （2）用法 SELECT ROUND(column_name,decimals) FROM table_name （3）例子 SELECT ProductName, ROUND(UnitPrice,0) as UnitPrice FROM Products- 4.16 NOW()（1）说明 NOW() 函数返回当前系统的日期和时间。 （2）用法 SELECT NOW() FROM table_name （3）例子 SELECT name, url, Now() AS date FROM Websites; 4.17 FORMAT()（1）说明 FORMAT() 函数用于对字段的显示进行格式化。 （2）用法 SELECT FORMAT(column_name,format) FROM table_name （3）例子 SELECT ProductName, UnitPrice, FORMAT(Now(),’YYYY-MM-DD’) as PerDate FROM Products 5、常见功能5.1 建库（1）用法 CREATE DATABASE （2）例子 5.2 修改库（1）用法 ALTER DATABASE （2）例子 5.3 删库（1）用法 DROP DATABASE （2）例子 5.4 建表（1）用法 CREATE TABLE （2）例子 5.5 修改表（1）用法 ALTER TABLE （2）例子 5.6 删表（1）用法 DROP TABLE （2）例子 5.7 建索引（1）用法 CREATE INDEX （2）例子 5.8 删索引（1）用法 DROP INDEX （2）例子 5.9 创建视图（1）用法 1234CREATE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition （2）例子 1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductNameFROM ProductsWHERE Discontinued=No 5.10 更新视图（1）用法 1234CREATE OR REPLACE VIEW view_name ASSELECT column_name(s)FROM table_nameWHERE condition （2）例子 1234CREATE VIEW [Current Product List] ASSELECT ProductID,ProductName,CategoryFROM ProductsWHERE Discontinued=No 5.11 删除视图（1）用法 DROP VIEW view_name （2）例子 6、实用例子1、查看表结构 show create table xxx （详细，推荐） describe xxx （简单） 2、查看一条数据的详细信息 select from where *** \\G (\\G的效果是竖直排列，左边是表头，右边是数据) 3、连接mysql数据库 mysql -hxxx(IP) -Pxxx(端口) -uxxx(用户名) -pxxx(密码) -A –default-charset=utf8 xxx(dbname) 4、合计 select sum(amount),count(1),date from xxx group by date 5、选择判断 select if(sex = 1,amount,-amount) from xxx where id = xxx 6、包括所有在 TableA 中但不在 TableB和TableC 中的行并消除所有重复行而派生出一个结果表1(select a from tableA ) except (select a from tableB) except (select a from tableC) 7、随机取出10条数据1select top 10 * from tablename order by newid() 8、初始化表table11TRUNCATE TABLE table1 9、选择第10到15的记录1select top 5 * from (select top 15 * from table order by id asc) table_别名 order by id desc 10、从两表中查询数据1select a.name , b.class from Userinfo a inner join Grade b using(userno)","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.xtcgch.ink/tags/数据库/"},{"name":"SQL","slug":"SQL","permalink":"https://blog.xtcgch.ink/tags/SQL/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】信号驱动IO","slug":"20181207-信号驱动IO","date":"2018-12-07T03:07:49.000Z","updated":"2020-11-22T02:40:54.105Z","comments":true,"path":"信号驱动IO/","link":"","permalink":"https://blog.xtcgch.ink/信号驱动IO/","excerpt":"摘要：","text":"摘要： 1、脑图 2、概述 3、原理首先来看信号驱动IO的模型图： 解读： 首先，开启套接字的信号驱动式IO功能，并通过sigaction系统调用安装一个信号处理函数。此时，系统调用立即返回，进程继续工作，即未被阻塞。 当内核数据包准备好之后，内核就为该进程准备一个sigio信号，进程的信号处理函数捕获到该信号时，就进入信号处理函数，然后调用recvfrom进行 读取数据。 当数据完成从内核空间复制到用户空间时 4、tcp套接字的sigio信号 5、udp套接字的sigio信号 6、demo 7、总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"IO","slug":"IO","permalink":"https://blog.xtcgch.ink/tags/IO/"},{"name":"网络编程","slug":"网络编程","permalink":"https://blog.xtcgch.ink/tags/网络编程/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】常用shell命令","slug":"20181206-shell命令","date":"2018-12-06T10:47:09.000Z","updated":"2020-11-22T02:40:51.411Z","comments":true,"path":"shell-commands/","link":"","permalink":"https://blog.xtcgch.ink/shell-commands/","excerpt":"摘要：本文主要记录centos系统中常用的shell命令。","text":"摘要：本文主要记录centos系统中常用的shell命令。 一、进程1、查看进程状态ps基本命令（1）ps -A：查看所有进程（包括pid，time）（2）ps -a：查看除控制进程和无终端进程外的所有进程（3）ps -d：查看除控制进程外的所有进程（4）ps -ef：查看所有进程的全部信息（5）ps -l：长格式输出（6）ps -f：ps常用命令：（1）ps -aux –sort -pcpu | less | head -n 5：根据cpu占用率降序排序（2） ps -aux –sort -pmem | less：根据内存占用率降序排序（3）ps -aux –sort -pcpu,+pmem | head -n 10：查询cpu和内存占用率最高的10个进程（4）ps -C getty：getty为进程启动的命令，该语句为筛选getty命令启动的进程（5）watch -n 1 ‘ps -aux –sort -pmem, -pcpu | less | head 20’：实时监控进程，根据cpu和内存使用率来排序，1秒刷新一次，只显示前20条（6）查看特定进程的情况（7）根据进程名查看进程pid： pgrep -f processname ps -ef | grep $process | grep -v grep | awk ‘{print $2}’ 查看系统所有进程的pid：top、ps -ef查看当前用户进程：ps -a把进程状态输出到文件：查看进程的running,sleeping,stopped,zombie状态：top | grep zombie 2、杀死进程kill pidkill -9 pid 3、daemon process（守护进程） 二、查看磁盘空间1、df（1）df（2）df -h（因子是1024）（3）df -H（因子是1000） 2、du（1）du（2）du -a：可显示个别文件的大小（3）du -c：可查看所有文件大小总和（4）du -s ：只显示合计大小 3、常用命令（1）du –max-depth=1 -h：查看当前目录下总大小和当前目录下深度为1的目录或文件的大小（2）du -sh：查看当前目录下总大小（3）du -h –max-depth=0：查看当前目录下总大小（4）du -sh /root/sw ：查看目标目录的大小 三、挂载1、mount [-t vfstype] [-o options] device dir（1）挂载iso文件mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom注释：光盘或光盘镜像：iso9660，loop：用来把一个文件当成硬盘分区挂接上系统 （2）挂接移动硬盘无中文：12mount -t ntfs /dev/sdc1 /mnt/usbhd1mount -t vfat /dev/sdc5 /mnt/usbhd2 有中文：mount -t ntfs -o iocharset=cp936 /dev/sdc1 /mnt/usbhd1 （3）挂载光驱mount /dev/hdc /mnt/cdrom （4）挂载软驱mount /dev/fd0 /mnt/floppy 附：（1）挂载解决中文问题：使用–o iocharset=cp936或–o iocharset=utf-8 2、umount（1）umount 设备：umount /dev/hda5（2）umount 目录：umount /mnt/hda5（3）umount 设备 目录：umount /dev/hda5 /mnt/hda5 四、perl1、perl脚本（1）执行linux命令 （2） 2、perl实现daemon参考文献：https://blog.csdn.net/xuleilx/article/details/8258798 – 五、软件管理1、安装rpm -ivh 2、更新rpm -Uvh 3、删除rpm -e 4、查询一个包是否被安装rpm -q &lt; rpm package name&gt; 5、得到被安装的包的信息rpm -qi &lt; rpm package name&gt; 6、列出该包中有哪些文件rpm -ql &lt; rpm package name&gt; 7、列出所有被安装的rpm packagerpm -qa 8、显示与目标包名相关的包rpm -qa | grep 包名 六、查看程序的安装1、安装路径rpm -qal |grep 2、软件版本软件名 -V(–version) 七、tcp连接状态1、查看8080端口上已经建立连接的tcp连接数netstat –nat | grep 8080 | grep ESTABLISHED| wc -l 八、网络相关121、netstat -rn 输出路由表2、netstat -ap 在上面命令的基础上列出连接的PID(进程号) 九、查看系统信息1、内核及发行版1234- uname -a - uname -sr - cat /etc/issue - lsb_release -a 2、CPU硬件cat /proc/cpuinfo 3、内存情况cat /proc/meminfo 4、磁盘、Swap情况fdisk -lfree -h 5、网络情况 ip a netstat -tln netstat -an | grep 80 | grep CONNECTED 6、网络协议和端口方面（root）： ss -l ss -ta ss -s 7、网络路由（root）： route -n 8、查看打开文件： lsof -i:22 查看物理CPU的个数 ：cat /proc/cpuinfo |grep “physical id”|sort |uniq|wc -l查看逻辑CPU的个数 ：cat /proc/cpuinfo |grep “processor”|wc -l查看CPU是几核：cat /proc/cpuinfo |grep physical |sort -u |wc -l 此命令为查看CPU的个数。查看内存大小：cat /proc/meminfo | grep -i “memtotal”查看内存插槽：dmidecode -t memory，dmidecode -t 17查看有内存条的插槽：dmidecode -t 17 | grep -i size CPU内存负载情况-vmstat -afsd内存使用情况：free 9、任务管理器top 查看特定进程：top -p pid 查看实时消息：top 其他1、发送http请求 curl:传送门 get请求：curl命令默认下就是使用get方式发送http请求。 1curl www.baidu.com post请求:使用-d 后面带 参数。 1curl -d &quot;param1=value1¶m2=value2&quot; www.baidu.com wget get请求： 最基本使用：wget www.baidu.com get方式并指定下载的文件名：wget -O wordpress.zip http://www.linuxde.net/download.aspx?id=1080 post请求：1wget --post-data=&quot;user=user1&amp;pass=pass1&amp;submit=Login&quot; http://domain.com/path/page_need_login.php 一些例子 查看xx进程的信息 1ps -ef | grep xxx 查看日志文件的最新动态 1tail -f xxx.log 管道的问题12345# file:note1234567890abcdefghij9876543210jihgfedcba 123456789# file；test.sh#! /bin/bashindex=0cat note | while read paramdo let index++ echo &quot;inter:index($index) param($param)&quot;doneecho &quot;outer:index($index)&quot; 输出： 12345inter:index(1) param(1234567890)inter:index(2) param(abcdefghij)inter:index(3) param(9876543210)inter:index(4) param(jihgfedcba)outer:index(0) 原因： 当启用管道时，会生成一个subshell，while循环的代码在subshell中执行，那么变量index也是在subshell中被修改， while循环结束后，回到主shell，index没有被修改，也就是说，两个index不是同一个index while中修改的index是外层index的副本 修正后的代码如下; 123456789# file；test.sh#! /bin/bashindex=0while read paramdo let index++ echo &quot;inter:index($index) param($param)&quot;done &lt; noteecho &quot;outer:index($index)&quot; 输出如下： 12345inter:index(1) param(1234567890)inter:index(2) param(abcdefghij)inter:index(3) param(9876543210)inter:index(4) param(jihgfedcba)outer:index(4) 下面是一本正经地开始当cv战士了 Shell 不完整教程 传送门 Shell 变量变量名的命名须遵循如下规则： 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。 变量名和等号之间不能有空格 不能使用标点符号 不能使用bash里的关键字（可用help命令查看保留关键字） 只读变量：readonly 12myUrl=&quot;http://www.google.com&quot;readonly myUrl 删除变量 使用 unset 命令可以删除变量。 unset 命令不能删除只读变量 1unset variable_name Shell 字符串 获取字符串长度 12string=&quot;abcd&quot;echo $&#123;#string&#125; #输出 4 提取子字符串 12string=&quot;runoob is a great site&quot;echo $&#123;string:1:4&#125; # 输出 unoo 查找子字符串 查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)： 12string=&quot;runoob is a great site&quot;echo `expr index &quot;$string&quot; io` # 输出 4 Shell 数组 定义数组 短小型： 1array_name=(value0 value1 value2 value3) 随意型：123456array_name=(value0value1value2value3) 折腾型：123456array_name[0]=value0array_name[1]=value1 . . .array_name[n]=valuen 读取数组 1valuen=$&#123;array_name[n]&#125; 使用 @ 符号可以获取数组中的所有元素 1echo $&#123;array_name[@]&#125; 获取数组的长度 123456# 取得数组元素的个数length=$&#123;#array_name[@]&#125;# 或者length=$&#123;#array_name[*]&#125;# 取得数组单个元素的长度lengthn=$&#123;#array_name[n]&#125; Shell 注释 单行注释 123456789101112#--------------------------------------------# 这是一个注释# author：# slogan：学的不仅是技术，更是梦想！#--------------------------------------------##### 用户配置区 开始 ######## 这里可以添加脚本描述信息# ###### 用户配置区 结束 ##### 多行注释 一本正经型：12345:&lt;&lt;EOF注释内容...注释内容...注释内容...EOF 耍小聪明型：1234567891011:&lt;&lt;&apos;注释内容...注释内容...注释内容...&apos;:&lt;&lt;!注释内容...注释内容...注释内容...! Shell 传递参数向脚本传递参数，脚本内获取参数的格式为：$n。n 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推 直接上代码： shell脚本内容12345678#!/bin/bash# author:echo &quot;Shell 传递参数实例！&quot;;echo &quot;执行的文件名：$0&quot;;echo &quot;第一个参数为：$1&quot;;echo &quot;第二个参数为：$2&quot;;echo &quot;第三个参数为：$3&quot;; 启动命令1./test.sh 1 2 3 参数处理 说明 $# 传递到脚本的参数个数 $* 以一个单字符串显示所有向脚本传递的参数 $$ 脚本运行的当前进程ID号 $! 后台运行的最后一个进程的ID号 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数。如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。 $- 显示Shell使用的当前选项，与set命令功能相同。 $? 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 demo:12345678910111213#!/bin/bash# author:# url:echo &quot;-- \\$* 演示 ---&quot;for i in &quot;$*&quot;; do echo $idoneecho &quot;-- \\$@ 演示 ---&quot;for i in &quot;$@&quot;; do echo $idone $* 与 $@ 区别和联系： 相同点：都是引用所有参数。 不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 “ * “ 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。 Shell 基本运算符 算数运算符 关系运算符 布尔运算符 字符串运算符 文件测试运算符 原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。 算术运算符123456789101112131415161718192021222324252627282930#!/bin/bash# author:菜鸟教程# url:www.runoob.coma=10b=20val=`expr $a + $b`echo &quot;a + b : $val&quot;val=`expr $a - $b`echo &quot;a - b : $val&quot;val=`expr $a \\* $b`echo &quot;a * b : $val&quot;val=`expr $b / $a`echo &quot;b / a : $val&quot;val=`expr $b % $a`echo &quot;b % a : $val&quot;if [ $a == $b ]then echo &quot;a 等于 b&quot;fiif [ $a != $b ]then echo &quot;a 不等于 b&quot;fi 注意： 表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。 完整的表达式要被 包含，注意这个字符不是常用的单引号，在 Esc 键下边。 乘号(*)前边必须加反斜杠()才能实现乘法运算 关系运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ $a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ $a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ $a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ $a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ $a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ $a -le $b ] 返回 true。 上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#!/bin/bash# author:# url:a=10b=20if [ $a -eq $b ]then echo &quot;$a -eq $b : a 等于 b&quot;else echo &quot;$a -eq $b: a 不等于 b&quot;fiif [ $a -ne $b ]then echo &quot;$a -ne $b: a 不等于 b&quot;else echo &quot;$a -ne $b : a 等于 b&quot;fiif [ $a -gt $b ]then echo &quot;$a -gt $b: a 大于 b&quot;else echo &quot;$a -gt $b: a 不大于 b&quot;fiif [ $a -lt $b ]then echo &quot;$a -lt $b: a 小于 b&quot;else echo &quot;$a -lt $b: a 不小于 b&quot;fiif [ $a -ge $b ]then echo &quot;$a -ge $b: a 大于或等于 b&quot;else echo &quot;$a -ge $b: a 小于 b&quot;fiif [ $a -le $b ]then echo &quot;$a -le $b: a 小于或等于 b&quot;else echo &quot;$a -le $b: a 大于 b&quot;fi 布尔运算符 运算符 说明 举例 ! 非运算，表达式为 true 则返回 false，否则返回 true。 [ ! false ] 返回 true。 -o 或运算，有一个表达式为 true 则返回 true。 [ $a -lt 20 -o $b -gt 100 ] 返回 true。 -a 与运算，两个表达式都为 true 才返回 true。 [ $a -lt 20 -a $b -gt 100 ] 返回 false。 上代码：12345678910111213141516171819202122232425262728293031#!/bin/bash# author:# url:a=10b=20if [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [ $a -lt 100 -a $b -gt 15 ]then echo &quot;$a 小于 100 且 $b 大于 15 : 返回 true&quot;else echo &quot;$a 小于 100 且 $b 大于 15 : 返回 false&quot;fiif [ $a -lt 100 -o $b -gt 100 ]then echo &quot;$a 小于 100 或 $b 大于 100 : 返回 true&quot;else echo &quot;$a 小于 100 或 $b 大于 100 : 返回 false&quot;fiif [ $a -lt 5 -o $b -gt 100 ]then echo &quot;$a 小于 5 或 $b 大于 100 : 返回 true&quot;else echo &quot;$a 小于 5 或 $b 大于 100 : 返回 false&quot;fi 逻辑运算符 运算符 说明 举例 &amp;&amp; 逻辑的 AND [[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false 两个或符合 逻辑的 OR [[ $a -lt 100 $b -gt 100 ]] 返回 true 简单的例子：1234567891011121314151617181920#!/bin/bash# author:# url:a=10b=20if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]then echo &quot;返回 true&quot;else echo &quot;返回 false&quot;fiif [[ $a -lt 100 || $b -gt 100 ]]then echo &quot;返回 true&quot;else echo &quot;返回 false&quot;fi 字符串运算符 运算符 说明 举例 = 检测两个字符串是否相等，相等返回 true。 [ $a = $b ] 返回 false。 != 检测两个字符串是否相等，不相等返回 true。 [ $a != $b ] 返回 true。 -z 检测字符串长度是否为0，为0返回 true。 [ -z $a ] 返回 false。 -n 检测字符串长度是否为0，不为0返回 true。 [ -n “$a” ] 返回 true。 $ 检测字符串是否为空，不为空返回 true。 [ $a ] 返回 true。 上代码：12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash# author:# url:a=&quot;abc&quot;b=&quot;efg&quot;if [ $a = $b ]then echo &quot;$a = $b : a 等于 b&quot;else echo &quot;$a = $b: a 不等于 b&quot;fiif [ $a != $b ]then echo &quot;$a != $b : a 不等于 b&quot;else echo &quot;$a != $b: a 等于 b&quot;fiif [ -z $a ]then echo &quot;-z $a : 字符串长度为 0&quot;else echo &quot;-z $a : 字符串长度不为 0&quot;fiif [ -n &quot;$a&quot; ]then echo &quot;-n $a : 字符串长度不为 0&quot;else echo &quot;-n $a : 字符串长度为 0&quot;fiif [ $a ]then echo &quot;$a : 字符串不为空&quot;else echo &quot;$a : 字符串为空&quot;fi 文件测试运算符 操作符 说明 举例 -b file 检测文件是否是块设备文件，如果是，则返回 true [ -b $file ] 返回 false。 -c file 检测文件是否是字符设备文件，如果是，则返回 true。 [ -c $file ] 返回 false。 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -g file 检测文件是否设置了 SGID 位，如果是，则返回 true。 [ -g $file ] 返回 false。 -k file 检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。 [ -k $file ] 返回 false。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -u file 检测文件是否设置了 SUID 位，如果是，则返回 true。 [ -u $file ] 返回 false。 -r file 检测文件是否可读，如果是，则返回 true。 [ -r $file ] 返回 true。 -w file 检测文件是否可写，如果是，则返回 true。 [ -w $file ] 返回 true。 -x file 检测文件是否可执行，如果是，则返回 true。 [ -x $file ] 返回 true。 -s file 检测文件是否为空（文件大小是否大于0），不为空返回 true。 [ -s $file ] 返回 true。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/bin/bash# author:# url:file=&quot;/var/www/runoob/test.sh&quot;if [ -r $file ]then echo &quot;文件可读&quot;else echo &quot;文件不可读&quot;fiif [ -w $file ]then echo &quot;文件可写&quot;else echo &quot;文件不可写&quot;fiif [ -x $file ]then echo &quot;文件可执行&quot;else echo &quot;文件不可执行&quot;fiif [ -f $file ]then echo &quot;文件为普通文件&quot;else echo &quot;文件为特殊文件&quot;fiif [ -d $file ]then echo &quot;文件是个目录&quot;else echo &quot;文件不是个目录&quot;fiif [ -s $file ]then echo &quot;文件不为空&quot;else echo &quot;文件为空&quot;fiif [ -e $file ]then echo &quot;文件存在&quot;else echo &quot;文件不存在&quot;fi Shell 流程控制 if else 123456789if conditionthen command1 command2 ... commandNelse commandfi if else-if else 123456789if condition1then command1elif condition2 then command2else commandNfi for 循环 1234567for var in item1 item2 ... itemNdo command1 command2 ... commandNdone in列表是可选的，如果不用它，for循环使用命令行的位置参数。 demo1:1234for loop in 1 2 3 4 5do echo &quot;The value is: $loop&quot;done 输出： 12345The value is: 1The value is: 2The value is: 3The value is: 4The value is: 5 demo2:1234for str in &apos;This is a string&apos;do echo $strdone 输出： 1This is a string while 语句1234while conditiondo commanddone demo1：1234567#!/bin/bashint=1while(( $int&lt;=5 ))do let &quot;int++&quot;doneecho $int 输出：15 demo2:1234567#!/bin/bashint=1while(( $int&lt;=5 ))do let int++doneecho $int 输出：11 demo3:123456echo &apos;按下 &lt;CTRL-D&gt; 退出&apos;echo -n &apos;输入你最喜欢的网站名: &apos;while read FILMdo echo &quot;是的！$FILM 是一个好网站&quot;done 无限循环 123456789101112131415while :do commanddone或while truedo commanddone或for (( ; ; )) until 循环 一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。 1234until conditiondo commanddone demo:123456789#!/bin/basha=0until [ ! $a -lt 10 ]do echo $a a=`expr $a + 1`done case1234567891011121314case 值 in模式1) command1 command2 ... commandN ;;模式2） command1 command2 ... commandN ;;esac 取值后面必须为单词in 每一模式必须以右括号结束 匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;; 每个case分支用右圆括号，用两个分号表示break 如果无一匹配模式，使用星号 * 捕获该值 esac（就是case反过来）作为结束标记 demo: 123456789101112131415echo &apos;输入 1 到 4 之间的数字:&apos;echo &apos;你输入的数字为:&apos;read aNumcase $aNum in 1) echo &apos;你选择了 1&apos; ;; 2) echo &apos;你选择了 2&apos; ;; 3) echo &apos;你选择了 3&apos; ;; 4) echo &apos;你选择了 4&apos; ;; *) echo &apos;你没有输入 1 到 4 之间的数字&apos; ;;esac Shell 函数 定义 123456789[ function ] funname [()]&#123; action; [return int;]&#125; 可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。 参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255) 返回值 demo1：（无return关键词）12345678910#!/bin/bash# author:菜鸟教程# url:www.runoob.comdemoFun()&#123; echo &quot;这是我的第一个 shell 函数!&quot;&#125;echo &quot;-----函数开始执行-----&quot;demoFunecho &quot;-----函数执行完毕-----&quot; 输出：123-----函数开始执行-----这是我的第一个 shell 函数!-----函数执行完毕----- demo2：（带return关键词）123456789101112131415#!/bin/bash# author:菜鸟教程# url:www.runoob.comfunWithReturn()&#123; echo &quot;这个函数会对输入的两个数字进行相加运算...&quot; echo &quot;输入第一个数字: &quot; read aNum echo &quot;输入第二个数字: &quot; read anotherNum echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot; return $(($aNum+$anotherNum))&#125;funWithReturnecho &quot;输入的两个数字之和为 $? !&quot; 输出：1234567这个函数会对输入的两个数字进行相加运算...输入第一个数字: 1输入第二个数字: 2两个数字分别为 1 和 2 !输入的两个数字之和为 3 ! 函数参数 在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 \\$n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数… 注意，$10 不能获取第十个参数，获取第十个参数需要${10}。当n&gt;=10时，需要使用${n}来获取参数。 带参数的函数示例：1234567891011121314#!/bin/bash# author:# url:funWithParam()&#123; echo &quot;第一个参数为 $1 !&quot; echo &quot;第二个参数为 $2 !&quot; echo &quot;第十个参数为 $10 !&quot; echo &quot;第十个参数为 $&#123;10&#125; !&quot; echo &quot;第十一个参数为 $&#123;11&#125; !&quot; echo &quot;参数总数有 $# 个!&quot; echo &quot;作为一个字符串输出所有参数 $* !&quot;&#125;funWithParam 1 2 3 4 5 6 7 8 9 34 73 输出：1234567第一个参数为 1 !第二个参数为 2 !第十个参数为 10 !第十个参数为 34 !第十一个参数为 73 !参数总数有 11 个!作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 ! 特殊字符: 参数处理 | 说明：–：|：–$# | 传递到脚本的参数个数$ | 以一个单字符串显示所有向脚本传递的参数$$ | 脚本运行的当前进程ID号$! | 后台运行的最后一个进程的ID号$@ | 与$相同，但是使用时加引号，并在引号中返回每个参数。$- | 显示Shell使用的当前选项，与set命令功能相同。$? | 显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。 mysql数据库操作文件io获取命令行参数获取参数个数count=$# 获取某个参数12param1=$1param2=$2","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"shell","slug":"shell","permalink":"https://blog.xtcgch.ink/tags/shell/"},{"name":"centos","slug":"centos","permalink":"https://blog.xtcgch.ink/tags/centos/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【故事】文章封面故事","slug":"story-index","date":"2018-12-06T06:50:50.000Z","updated":"2020-11-22T02:42:04.971Z","comments":true,"path":"story-index/","link":"","permalink":"https://blog.xtcgch.ink/story-index/","excerpt":"摘要: 这个栏目是用来介绍每篇文章的封面中包含的故事，构造这样的一个栏目的目的是让我保持写博客的习惯。","text":"摘要: 这个栏目是用来介绍每篇文章的封面中包含的故事，构造这样的一个栏目的目的是让我保持写博客的习惯。","categories":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}],"tags":[{"name":"故事","slug":"故事","permalink":"https://blog.xtcgch.ink/tags/故事/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://blog.xtcgch.ink/categories/其他/"}]},{"title":"【原理】TCP和UDP协议的一些理解","slug":"20181124-TCP和UDP","date":"2018-11-24T14:49:27.000Z","updated":"2020-11-22T02:40:48.743Z","comments":true,"path":"tcp&udp/","link":"","permalink":"https://blog.xtcgch.ink/tcp&udp/","excerpt":"摘要：本文主要讲CentOS6和7中MYSQL的安装和配置相关的知识点。","text":"摘要：本文主要讲CentOS6和7中MYSQL的安装和配置相关的知识点。 协议的区别1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保 证可靠交付 3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的 UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等） 4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信 5、TCP首部开销20字节;UDP的首部开销小，只有8个字节 6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道 具体编程时的区别1.socket()的参数不同 2.UDP Server不需要调用listen和accept 3.UDP收发数据用sendto/recvfrom函数 4.TCP：地址信息在connect/accept时确定 5.UDP：在sendto/recvfrom函数中每次均 需指定地址信息 6.UDP：shutdown函数无效 UDP应用场景1.面向数据报方式 2.网络数据大多为短消息 3.拥有大量Client 4.对数据安全性无特殊要求 5.网络负担非常重，但对响应速度要求高 UDP编程的服务器端一般步骤是1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt();* 可选 3、绑定IP地址、端口等信息到socket上，用函数bind(); 4、循环接收数据，用函数recvfrom(); 5、关闭网络连接； UDP编程的客户端一般步骤是1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt();* 可选 3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 4、设置对方的IP地址和端口等属性; 5、发送数据，用函数sendto(); 6、关闭网络连接； TCP编程的服务器端一般步骤是1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt(); * 可选 3、绑定IP地址、端口等信息到socket上，用函数bind(); 4、开启监听，用函数listen()； 5、接收客户端上来的连接，用函数accept()； 6、收发数据，用函数send()和recv()，或者read()和write(); 7、关闭网络连接； 8、关闭监听； TCP编程的客户端一般步骤是1、创建一个socket，用函数socket()； 2、设置socket属性，用函数setsockopt();* 可选 3、绑定IP地址、端口等信息到socket上，用函数bind();* 可选 4、设置要连接的对方的IP地址和端口等属性； 5、连接服务器，用函数connect()； 6、收发数据，用函数send()和recv()，或者read()和write(); 7、关闭网络连接； TCP和UDP的应用 TCP和UDP协议的比较 TCP/UDP编程模型","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"网络","slug":"网络","permalink":"https://blog.xtcgch.ink/tags/网络/"},{"name":"TCP","slug":"TCP","permalink":"https://blog.xtcgch.ink/tags/TCP/"},{"name":"UDP","slug":"UDP","permalink":"https://blog.xtcgch.ink/tags/UDP/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】CentOS6-7安装MYSQL数据库","slug":"20181124-CentOS安装MYSQL","date":"2018-11-24T14:49:27.000Z","updated":"2020-11-22T02:40:45.558Z","comments":true,"path":"mysql-install/","link":"","permalink":"https://blog.xtcgch.ink/mysql-install/","excerpt":"摘要：本文主要讲CentOS6和7中MYSQL的安装和配置相关的知识点。","text":"摘要：本文主要讲CentOS6和7中MYSQL的安装和配置相关的知识点。 1. 下载mysql的repo源CentOS7的yum源中默认是没有mysql的。为了解决这个问题，我们要先下载mysql的repo源。 1wget http://repo.mysql.com/+rpm包 2、安装rpm包1sudo rpm -ivh+rpm包 安装了之后在/etc/yum.repos.d/文件夹下会有2个repo包：1、mysql-community.repo2、mysql-community-source.repo 3、安装mysql1sudo yum install mysql-server 4、启动mysql123service mysqld start或systemctl start mysqld.service 5、检查mysql 的运行状态123service mysqld status或systemctl status mysqld.service 6、修改临时密码Mysql5.7默认安装之后root是有密码的。 6.1 获取MySQL的临时密码为了加强安全性，MySQL5.7为root用户随机生成了一个密码，在error log中，关于error log的位置，如果安装的是RPM包，则默认是/var/log/mysqld.log。 只有启动过一次mysql才可以查看临时密码 查看临时密码： 1grep &apos;temporary password&apos; /var/log/mysqld.log 6.2 登陆并修改密码使用默认密码登录： 1mysql -uroot -p 修改密码 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Abc9876543210.&apos;; 注意：可能因为设置的密码安全性太低而会被警告，修改不成功！ 授权其他机器进行连接 12GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;Abc9876543210.&apos; WITH GRANT OPTION;FLUSH PRIVILEGES; 注意：这里的mypassword是其他机器连接时的密码。 如果修改不成功，可能是密码的加密方式不正确 123ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Abc9876543210.&apos; PASSWORD EXPIRE NEVER;ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;Abc9876543210.&apos;;FLUSH PRIVILEGES; 监听所有ip地址的连接 12vim /etc/my.cnfbind-address=0.0.0.0 7、防火墙开放3306端口1、进入防火墙配置文件 1sudo vim /etc/sysconfig/iptables 2、添加防火墙规则 1-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT 3、重启防火墙服务 1sudo service iptables","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.xtcgch.ink/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.xtcgch.ink/tags/MySQL/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.xtcgch.ink/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"https://blog.xtcgch.ink/tags/CentOS/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】数据库知识","slug":"20181123-数据库学习","date":"2018-11-23T14:49:27.000Z","updated":"2020-11-22T02:40:37.973Z","comments":true,"path":"database/","link":"","permalink":"https://blog.xtcgch.ink/database/","excerpt":"摘要：本文主要讲数据库相关的知识点。","text":"摘要：本文主要讲数据库相关的知识点。 1、索引与散列1.1 索引1.1.1 基本术语搜索码：指数据表的字段，如name 搜索码值：指该字段下的值，如zhangsan 1.1.2 稠密索引稠密索引是索引记录和数据表记录一一对应的，即每条索引对应一条记录。 1.1.3 稀疏索引稀疏索引是只为某些记录建立索引记录。 1.1.4 聚集索引聚集索引是指索引的排列顺序和记录的排列顺序是一致的。 1.1.5 非聚集索引非聚集索引则没有这个要求。 1.1.6 稠密，稀疏索引和聚集，非聚集索引的区别稠密，稀疏索引是以是否与表记录一一对应来划分；而聚集索引和非聚集索引是以索引的排列顺序与表记录的排列顺序是否相同来划分。 1.1.7 使用心得1.外层索引一定是稀疏索引。 2. 1.1.8 B+树索引（1）叶节点（2）非叶结点（3）一次查找的时间log[n/2]（k）:n指根节点到一个叶节点路径上的节点数，k指搜索码值 1.1.9 多码访问（1）使用多个单码索引使用多个单码索引即根据每个搜索码查找符合条件的记录，然后利用交集来获取最终的结果 （2）多码索引索引码为复合搜索码，即由多个属性组合而成； 搜索码值的顺序是词典顺序 1.2 散列","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://blog.xtcgch.ink/tags/数据库/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】类","slug":"20181123-类","date":"2018-11-23T14:49:27.000Z","updated":"2020-11-22T02:40:42.190Z","comments":true,"path":"class/","link":"","permalink":"https://blog.xtcgch.ink/class/","excerpt":"摘要：本文主要讲C++中类相关的知识点。","text":"摘要：本文主要讲C++中类相关的知识点。 模板类 只能在头文件中定义和实现 虚函数表、虚指针、纯虚函数 虚函数表在编译时开始生成 虚指针在运行时生成 纯虚函数每个类中只能有一个，并且占用4(32位机)/8(64位机)个字节 ##成员初始化列表 按照成员的定义顺序来初始化 ##重写构造函数，=，[]，&gt;，&lt; ClassA&amp; operator=(const ClassA&amp;){} ClassA operator\\{} ClassA operator&gt;(const ClassA&amp;){} ClassA operator&lt;(const ClassA&amp;){} ##指针成员的内存分配和内存释放 new 和delete new[]和delete[] char * p =0 ; const在函数中的用法 const定义参数时可以当做判断重载的条件之一 const主要是为了提高效率 （1）fun（）const {} 表示fun不能改变修改类的成员。可用在一些只读数据的函数中，避免程序员误操作对数据进行了修改 （2）const string &amp; fun（）{} 表示返回string对象的常量引用 const在指针中的用法（1）const char p == char const p p所指内容是常量 （2）char * const p p是常量，所指向的内容可以修改 空类的大小占1个字节 explicit的使用常用在赋值构造函数，表明要显示调用 派生类向基类转换1Derive d=new Base(); 构造函数的调用场景（1）无参构造函数 先基类，后派生类 （2）赋值构造函数 函数参数的传递 （3）复制构造函数–&gt;oprater== 函数返回值（似乎已经进行了优化，不再提供类型转换，即赋值构造函数的调用了） （4）析构函数 先基类，后派生类 区分构造函数、赋值构造函数和复制构造函数的调用（1）A a–&gt;构造函数 （2）A a =b–&gt;初始化 （3）A a,b;a=b;–&gt;赋值构造函数 指针成员的初始化（1）定义char * p （2）在默认构造函数中：p=new char[1];p[0]=’ \\0 ‘; 目的有： 为了防止p为野指针 为了析构函数能正常调用delete[]","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"类","slug":"类","permalink":"https://blog.xtcgch.ink/tags/类/"},{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】指针和引用","slug":"20181123-指针","date":"2018-11-23T14:49:27.000Z","updated":"2020-11-22T02:40:34.037Z","comments":true,"path":"pointer&ref/","link":"","permalink":"https://blog.xtcgch.ink/pointer&ref/","excerpt":"摘要：本文主要讲C++中指针相关的知识点。","text":"摘要：本文主要讲C++中指针相关的知识点。 1、脑图 2、概述 3、特点（1）指针 （2）引用 4、指针类别4.1 空指针 在C++11之前，使用0或者NULL来赋予空指针 在C++11之后，使用nullptr来赋予空指针 4.2 智能指针1、简介：（1）头文件（2）在C++11标准后才正式可用 2、shared_ptr&lt;&gt;()（1）特点 引用计数，复制时只是复制指针，当计数为0时，调用元素的析构函数（2）初始化：使用make_shared&lt;&gt;()进行构造智能指针（3）复制：（4）注意事项： 3、unique_ptr&lt;&gt;()（1）特点 unique_ptr只能有一个使用权，不同的unique_ptr之间只能进行move转移使用权（2）初始化：使用make_unique&lt;&gt;()进行构造只能指针（3）复制：（4）注意事项： 4、weak_ptr&lt;&gt;()（1）特点 unique_ptr只能有一个使用权，不同的unique_ptr之间只能进行move转移使用权（2）初始化：使用make_unique&lt;&gt;()进行构造只能指针（3）复制：（4）注意事项： 4.3 数组指针1、简介本质是一个指针，指向一个数组 2、声明和定义int (* p)[10]; p、* p++、p[1] 3、删除delete[] 4、例子1234int a[3][4];int (* p)[4]; //该语句是定义一个数组指针，指向含4个元素的一维数组。 p=a; //将该二维数组的首地址赋给p，也就是a[0]或&amp;a[0][0] p++; //该语句执行过后，也就是p=p+1;p跨过行a[0][]指向了行a[1][] 4.4 指针数组1、简介本质是一个数组，存放的都是指针 2、声明和定义int * (p[]) 3、删除delete[] p 4、例子int p[3];int a[3][4];p++; //该语句表示p数组指向下一个数组元素。注：此数组每一个元素都是一个指针for(i=0;i&lt;3;i++)p[i]=a[i]这里int p[3] 表示一个一维数组内存放着三个指针变量，分别是p[0]、p[1]、p[2]所以要分别赋值。比如要表示数组中i行j列一个元素： (p[i]+j)、 ( (p+i)+j)、(* (p+i))[j]、p[i][j] 5、指针操作5.1 移动当指针为数组指针时，有2种移动指针的方法，一种是使用加法：p+=n，一种是使用下标：p[n]。 5.2 初始化和赋值（1）可以使用zeromemory()和memset()函数来进行指针初始化。（2）可以使用memcpy()函数来进行数组指针的赋值。 5.3 内存申请和删除（1）使用new进行申请内存，通过判断p是否为空指针来知晓是否申请内存成功（2）new申请的内存： 指针指向单个对象时，使用delete进行删除 指针指向数组时，使用delete[]进行删除 6、指针和引用的区别 定义和性质区别： （1）指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元; 而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已 （2）可以有const指针，但是没有const引用 （3）指针可以有多级，但是引用只能是一级（int ** p；合法 而 int &amp;&amp;a是不合法的） （4）指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化 (5)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了 (6)”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小 (7)指针和引用的自增(++)运算意义不一样 作为函数参数进行传递时的区别 指针传递的是一个副本，引用传递的是本身 7、注意事项（1）空指针 使用时需要先判断是否为空指针，方法有if(nullptr==p)或者assert(nullptr==p) 如果指针指向了一块堆内的内存，如果在未删除内存时把指针设为空指针，则造成了内存泄漏 （2）野指针 造成原因：删除指针指向的内存后，未给指针赋空值，所以原指针指向了一个不确定的内存 解决方案：删除指针指向的内存后，使用nullptr赋值为空指针","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://blog.xtcgch.ink/tags/C/"},{"name":"指针","slug":"指针","permalink":"https://blog.xtcgch.ink/tags/指针/"},{"name":"引用","slug":"引用","permalink":"https://blog.xtcgch.ink/tags/引用/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】内存分配、管理和算法","slug":"20181122-内存分配","date":"2018-11-23T08:00:00.000Z","updated":"2020-11-22T02:40:18.880Z","comments":true,"path":"memory-allocate/","link":"","permalink":"https://blog.xtcgch.ink/memory-allocate/","excerpt":"摘要：内存分配是指在程序执行的过程中分配或者回收存储空间的分配内存的方法。","text":"摘要：内存分配是指在程序执行的过程中分配或者回收存储空间的分配内存的方法。 栈和堆（1）栈上的内存主要是由操作系统分配，不会发生内存泄漏，堆上的内存一般由程序员分配释放，若不释放，程序结束时可能由OS回收 （2）栈上的分配内存的大小是有限制，超出上限会分配失败，而堆上的内存分配则是没有大小限制 （3）堆区是公有的，栈区是线程独有的 （4）什么是堆：堆是大家共有的空间，分全局堆和局部堆。全局堆就是所有没有分配的空间，局部堆就是用户分配的空间。堆在操作系统对进程 初始化的时候分配，运行过程中也可以向系统要额外的堆，但是记得用完了要还给操作系统，要不然就是内存泄漏。 什么是栈：栈是线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立。每个函数都有自己的栈，栈被用来在函数之间传递参数。操作系统在切换线程的时候会自动的切换栈，就是切换SS/ESP寄存器。栈空间不需要在高级语言里面显式的分配和释放。 注意：堆区与数据结构中的堆是两回事，分配方式倒是类似于链表。 错误示例： void Function(void) { char *p = (char *)malloc(100 * sizeof(char)); } 就这个例子，千万不要认为函数返回，函数所在的栈被销毁指针也跟着销毁，申请的内存也就一样跟着销毁了！这绝对是错误的！因为申请的内存在堆上，而函数所在的栈被销毁跟堆完全没有啥关系。 动态内存分配和静态内存分配动态内存分配动态内存分配(Dynamic Memory Allocation)就是指在程序执行的过程中动态地分配或者回收存储空间的分配内存的方法。动态内存分配不象数组等静态内存分配方法那样需要预先分配存储空间，而是由系统根据程序的需要即时分配，且分配的大小就是程序要求的大小。 静态内存分配静态的内存使用的是栈空间内存，不用程序员自己来分配。因为静态变量占用的存储空间对于编译器而言是可预计的，静态内存只需要编程的时候直接声明就可以了。 malloc 和 new1、联系 （1）都是动态分配内存 （2）在释放内存后，原指针要进行相关的处理 2、区别 （1）申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间（自由存储区可以是堆，可以是静态存储区） malloc函数从堆上动态分配内存 （2）返回类型安全性 new是符合类型安全性的操作符：new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换 malloc是非类型安全性的操作符：malloc内存分配成功则是返回void * ，需要通过强制类型转换将void * 指针转换成我们需要的类型 （3）内存分配失败时的返回值 new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL malloc分配内存失败时返回NULL，需要去判断是否分配成功 malloc检查分配内存是否成功： 123456789int *a = (int *)malloc ( sizeof (int ));if(NULL == a)&#123; ...&#125;else &#123; ...&#125; new检查分配内存是否成功： 12345678try&#123; int *a = new int();&#125;catch (bad_alloc)&#123; ...&#125; （4）是否需要指定内存大小 new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸 121、int* parr = new int [100] ; 则分配大小为 sizeof(int) * 100 2、int* parr = （int *）malloc （100 * sizeof（int）） （5）是否调用构造函数/析构函数 使用new操作符来分配对象内存时会经历三个步骤： 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。第三步：对象构造完成后，返回一个指向该对象的指针。 使用delete操作符来释放对象内存时会经历两个步骤： 第一步：调用对象的析构函数。 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。 总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。 （6）对数组的处理 new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。 注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。 所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小 （7）new与malloc是否可以相互调用 operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new （8）是否可以被重载 opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本 而malloc/free并不允许重载 （9）能够直观地重新分配内存 使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。 realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有这样直观的配套设施来扩充内存。 （10）客户处理内存分配不足 在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler 对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL 注意：（1）重复分配内存会使得内存泄漏（2）重复释放内存会发生错误 连续内存分配方式1）固定分区分配 将内存划分成若干个固定大小的块。将程序装入块中即可。内存划分成各个块之后，块大小不再改变。当然，划分块的方式有：所有的块大小相等；划分的块大小不相等。 这种方式，在实际的内存分配之前，就已经知道了所有的内存块大小了。 2）动态分区分配 需要一个空闲表 或者 空闲链 来记录目前系统中空间的内存区域。在内存分配时，需要查找空间表或空闲链找到一块内存分配给当前进程。 动态分区分配算法： a)首次适应法 b)循环首次适应法 c)最佳适应法 d)最坏适应法 e)快速适应法 3）可重定位分区分配 说白了，就是增加了内存移动的功能。由于若干次内存分配与回收之后，各个空闲的内存块不连续了。通过“重定位”，将已经分配的内存“紧凑”在一块（就类似于JVM垃圾回收中的复制算法）从而空出一大块空闲的内存出来。 ”紧凑“是需要开销的，比如需要重新计算 地址，这也为什么JVM垃圾回收会导致STW的原因。 而离散分配方式–不管是分页还是分段，都是直接将程序放到各个离散的页中。从而就不存在“紧凑”一说了。 连续内存分配方式涉及两种操作：内存分配操作 和 内存回收操作 离散内存分配方式内存资源是有限的，程序要运行，必须得加载到内存。如果内存已经满了，而现在又有新的程序要运行，怎么办？—SWAP 把当前不用的程序(数据)先换出内存，从而就有空间 加载当前需要运行的程序的一部分数据进入内存，这样大大提高了内存的利用率。 由于牵涉到换入与换出，前面的连续内存分配方式就有点不适用了。因为，最明显的一个问题：对于连续内存分配方式，究竟换出哪部分数据呢？ 而这种只装入部分”数据”就可以使程序运行的机制，就是虚拟存储器的本质。 参考文章 文章一 文章二","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"内存管理","slug":"内存管理","permalink":"https://blog.xtcgch.ink/tags/内存管理/"},{"name":"内存分配","slug":"内存分配","permalink":"https://blog.xtcgch.ink/tags/内存分配/"},{"name":"操作系统","slug":"操作系统","permalink":"https://blog.xtcgch.ink/tags/操作系统/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】管道通信","slug":"20181122-管道通信","date":"2018-11-23T08:00:00.000Z","updated":"2020-11-22T18:51:43.019Z","comments":true,"path":"pipel-communication/","link":"","permalink":"https://blog.xtcgch.ink/pipel-communication/","excerpt":"摘要：管道通信是进程间通信的一种方式。学习管道通信对于linux下C++多进程编程有很大的帮助。","text":"摘要：管道通信是进程间通信的一种方式。学习管道通信对于linux下C++多进程编程有很大的帮助。 管道的介绍管道其实是内核内存中维护的一个缓冲器 匿名管道（PIPE）A.管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道 B.只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程); C.单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。 D.数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。 命名管道（FIFO）FIFO不同于无名管道之处在于它提供了一个路径名与之关联，以FIFO的文件形式存在于文件系统中。 这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信。 因此，通过FIFO不相关的进程也能交换数据。 值的注意的是，FIFO严格遵循先进先出(first in first out),对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。 它们不支持诸如lseek()等文件定位操作。 注意：有名管道的名字存在于文件系统中，内容存放在内存中。 管道的使用匿名管道 函数 int pipe（int filedis[2]） 命名管道 函数 int mkfifo(const char *pathname,mode_t mode) 总结","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"IPC","slug":"IPC","permalink":"https://blog.xtcgch.ink/tags/IPC/"},{"name":"管道","slug":"管道","permalink":"https://blog.xtcgch.ink/tags/管道/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】makefile语法","slug":"20181122-makefile","date":"2018-11-23T08:00:00.000Z","updated":"2020-11-22T02:40:13.835Z","comments":true,"path":"makefile/","link":"","permalink":"https://blog.xtcgch.ink/makefile/","excerpt":"摘要：在unix/linux服务器下编译工程时，特别是大型工程，使用makefile语法是一个非常好的选择。","text":"摘要：在unix/linux服务器下编译工程时，特别是大型工程，使用makefile语法是一个非常好的选择。 脑图 简述 Makefile里有什么？ Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。 （1）显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。 （2）隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。 （3）变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。 （4）文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。 （5）注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。 Makefile的文件名 （1）默认情况：“GNUmakefile”、“makefile”、“Makefile” （2）自定义：“Make.Linux”，“Make.Solaris”，“Make.AIX” Make （1）默认文件：“GNUmakefile”、“makefile”、“Makefile” （2）指定要make的文件：make -f filename或make -file filename,如：make -f Make.Linux或make --file Make.AIX。 make运行时机 make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令 目的 自动化管理工程项目的编译命令 工作原理 编译 编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件） 链接 链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。 使用规则环境变量 变量的基础 声明时，需要给变量赋予初值使用时，需要给在变量名前加上“$”符号，但最好用小括号“（）”或是大括号“{}”把变量给包括起来。如果你要使用真实的“$”字符，那么你需要用“$$”来表示。变量可以使用在许多地方，如规则中的“目标”、“依赖”、“命令”以及新的变量中。 （1）变量定义 1objects = program.o foo.o utils.o （2）变量的引用 12program : $(objects)cc -o program $(objects) 变量会在使用它的地方精确地展开，就像C/C++中的宏一样 123foo = prog.cprog.o : $(foo)cc -c $(foo) 展开后得到： 12prog.o : prog.ccc -c prog.c 变量的变量 在定义变量的值时，我们可以使用其它变量来构造变量的值，在Makefile中有两种方式来在用变量定义变量的值 第一种方式：简单的使用“=”号，在=左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处12345foo = $(bar)bar = $(ugh)ugh = Huh?all:echo $(foo) 输出： 1Huh? 第二种方式：使用的是:=操作符, 并且必须先定义变量，才能被引用123x := fooy := $(x) barx := later 等价于 12y := foo barx := later 变量值的替换 普通模式 替换变量中的共有的部分，其格式是$(var:a=b)或是${var:a=b}，其意思是，把变量var中所有以a字串“结尾”的a替换成b字串。这里的“结尾”意思是空格或是结束符 12foo := a.o b.o c.obar := $(foo:.o=.c) 解释： 先定义了一个$(foo)变量，而第二行的意思是把$(foo)中所有以.o字串结尾全部替换成.c，所以我们的“$(bar)”的值就是a.c b.c c.c 静态模式 12foo := a.o b.o c.obar := $(foo:%.o=%.c) 这依赖于被替换字串中的有相同的模式，模式中必须包含一个“%”字符，这个例子同样让$(bar)变量的值为“a.c b.c c.c” 把变量的值再当成变量 123x = yy = za := $($(x)) 在这个例子中，$(x)的值是“y”，所以$($(x))就是$(y)，于是$(a)的值就是“z”。（注意，是“x=y”，而不是“x=$(y)”） 追加变量值 12objects = main.o foo.o bar.o utils.oobjects += another.o $(objects)值：main.o foo.o bar.o utils.o another.o override 指示符 如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想在Makefile中设置这类参数的值，那么，你可以使用“override”指示符。其语法是：12override &lt;variable&gt; = &lt;value&gt;override &lt;variable&gt; := &lt;value&gt; 追加： 1override &lt;variable&gt; += &lt;more text&gt; 多行变量 语法： define 指示符后面跟的是变量的名字，另起一行定义变量的值，以endef关键字结束定义。 1234define two-linesecho fooecho $(bar)endef 环境变量 make 运行时的系统环境变量可以在make开始运行时被载入到Makefile文件中,但是如果Makefile中已定义了这个变量,或是这个变量由make命令行带入,那么系统的环境变量的值将被覆盖。 如果我们在环境变量中设置了CFLAGS环境变量，那么我们就可以在所有的Makefile中使用这个变量了 如果Makefile中定义了CFLAGS,那么则会使用Makefile中的这个变量,如果没有定义则使用系统环境变量的值 当make嵌套调用时,上层Makefile中定义的变量会以系统环境变量的方式传递到下层的Makefile中 默认情况下,只有通过命令行设置的变量会被传递。而定义在文件中的变量,如果要向下层 Makefile传递,则需要使用exprot关键字来声明 目标变量 为某个目标设置局部变量,它可以和“全局变量”同名,因为它的作用范围只在这条规则以及连带规则中,所以其值也只在作用范围内有效,而不会影响规则链以外的全局变量的值 语法： 12&lt;target ...&gt; : &lt;variable-assignment&gt;&lt;target ...&gt; : overide &lt;variable-assignment&gt; &lt;variable-assignment&gt;可以是前面讲过的各种赋值表达式，如“=”、“:=”、“+=”或是“？=”。第二个语法是针对于make命令行带入的变量，或是系统环境变量。 示例： 123456789101112131415prog : CFLAGS = -gprog : prog.o foo.o bar.o$(CC) $(CFLAGS) prog.o foo.o bar.oprog.o : prog.c$(CC) $(CFLAGS) prog.cfoo.o : foo.c$(CC) $(CFLAGS) foo.cbar.o : bar.c$(CC) $(CFLAGS) bar.c 不管全局的$(CFLAGS)的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则），$(CFLAGS)的值都是“-g” 模式变量 1%.o : CFLAGS = -O 或 12345678910libs_for_gcc = -lgnunormal_libs =foo: $(objects)ifeq ($(CC),gcc)$(CC) -o foo $(objects) $(libs_for_gcc)else$(CC) -o foo $(objects) $(normal_libs)endif 语法规则 基础使用 123target... : prerequisites ... command ... target也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisites就是，要生成那个target所需要的文件或是目标。 command也就是make需要执行的命令。（任意的Shell命令） 12foo.o: foo.c defs.h # foo模块 cc -c -g foo.c 注解：（1）foo.o是target，目标文件；（2）foo.c defs.h是prerequisites，依赖文件；（3）cc -c -g foo.c就是command，即make需要执行的命令。 规则包含两个部分，一个是依赖关系，一个是生成目标的方法。 函数方面 函数调用 123（1）$(&lt;function&gt; &lt;arguments&gt; )（2）$&#123;&lt;function&gt; &lt;arguments&gt;&#125; 例子： 1“$(subst a,b,$(x))” 其中，subst就是函数名，a,b,S(x)就是参数 字符串函数 1$(subst &lt;from&gt;,&lt;to&gt;,&lt;text&gt; ) 示例 1$(subst ee,EE,feet on the street) 作用：把feet on the street中的ee替换成EE结果：返回fEEt on the strEEt。 加前缀函数——addprefix 功能：把前缀加到中的每个单词后面。返回：返回加过前缀的文件名序列。示例：$(addprefix src/,foo bar)返回值是“src/foo src/bar” 加后缀函数——addsuffix 功能：把后缀加到中的每个单词后面。返回：返回加过后缀的文件名序列。示例：$(addsuffix .c,foo bar)返回值是“foo.cbar.c” 取前缀函数——basename 功能：从文件名序列中取出各个文件名的前缀部分。返回：返回文件名序列的前缀序列，如果文件没有前缀，则返回空字串。示例：$(basename src/foo.c src-1.0/bar.c hacks)返回值是“src/foo src-1.0/bar hacks” 取后缀函数——suffix 功能：从文件名序列中取出各个文件名的后缀。返回：返回文件名序列的后缀序列，如果文件没有后缀，则返回空字串。示例：$(suffix src/foo.c src-1.0/bar.chacks)返回值是“.c.c” 取目录函数——dir 功能：从文件名序列中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前的部分。如果没有反斜杠，那么返回“./”。返回：返回文件名序列的目录部分。示例：$(dir src/foo.c hacks)返回值是“src/./” foreach 函数 这个函数的意思是，把参数中的单词逐一取出放到参数所指定的变量中，然后再执行所包含的表达式。每一次会返回一个字符串，循环过程中， 的所返回的每个字符串会以空格分隔，最后当整个循环结束时，所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。 所以，最好是一个变量名，可以是一个表达式，而中一般会使用这个参数来依次枚举中的单词 示例： 12names := a b c dfiles := $(foreach n,$(names),$(n).o) 输出：a.o b.o c.o d.o if 函数 12$(if &lt;condition&gt;,&lt;then-part&gt; )$(if &lt;condition&gt;,&lt;then-part&gt;,&lt;else-part&gt; ) call函数 语法：$(call ,,,…)功能：当make执行这个函数时，参数中的变量，如$(1)，$(2)，$(3)等，会被参数，，依次取代。而的返回值就是call函数的返回值。示例：123reverse = $(1) $(2)foo = $(call reverse,a,b)echo $(reverse) 输出：a b origin函数语法：$(origin )origin函数的返回值:undefined: 从来没有定义过，origin函数返回这个值“undefined”。default:是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。environment:是一个环境变量，并且当Makefile被执行时，“-e”参数没有被打开file:被定义在Makefile中command line:被命令行定义override:被override指示符重新定义automatic:一个命令运行中的自动化变量 shell函数功能：用操作系统命令以及字符串处理命令awk，sed等等命令示例： 123456789contents := $(shell cat foo)files := $(shell echo \\*.c)``` - **控制make的函数**- **include函数**在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是： includefilename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）12在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句： include foo.make *.mk $(bar)12等价于： include foo.make a.mk b.mk c.mk e.mk f.mk12make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找： 1.如果make执行时，有“-I”或“–include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。12如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如： -include12345678910其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。- **去空格函数 - strip**语法：`$(strip &lt;string&gt; )`功能：去掉&lt;string&gt;字串中开头和结尾的空字符。返回：返回被去掉空格的字符串值。示例： $(strip a b c )把字串“abc”去到开头和结尾的空格，结果是“abc”1234567- **查找字符串函数 - findstring**语法：`$(findstring &lt;find&gt;,&lt;in&gt; )`功能：在字串&lt;in&gt;中查找&lt;find&gt;字串。返回：如果找到，那么返回&lt;find&gt;，否则返回空字符串。示例： $(findstring a,a b c)$(findstring a,b c)12345678910第一个函数返回“a”字符串，第二个返回“”字符串（空字符串）$(filter &lt;pattern...&gt;,&lt;text&gt; )- **过滤函数 - filter**语法：`$(filter &lt;pattern...&gt;,&lt;text&gt; )`功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，保留符合模式&lt;pattern&gt;的单词。可以有多个模式。返回：返回符合模式&lt;pattern&gt;的字串。示例： sources := foo.c bar.c baz.s ugh.hfoo: $(sources)cc $(filter %.c %.s,$(sources)) -o foo1234567891011返回的值是“foo.c bar.c baz.s”- **反过滤函数——filter-out**语法：`$(filter-out &lt;pattern...&gt;,&lt;text&gt; )`名称：反过滤函数——filter-out。功能：以&lt;pattern&gt;模式过滤&lt;text&gt;字符串中的单词，去除符合模式&lt;pattern&gt;的单词。可以有多个模式。返回：返回不符合模式&lt;pattern&gt;的字串。示例： objects=main1.o foo.o main2.o bar.omains=main1.o main2.o12345678910111213141516171819202122232425262728293031323334353637$(filter-out $(mains),$(objects)) 返回值是“foo.o bar.o”- **排序函数——sort**语法：`$(sort &lt;list&gt; )`功能：给字符串&lt;list&gt;中的单词排序（升序）。返回：返回排序后的字符串。示例：$(sortfoobarlose)返回“barfoolose”。备注：sort函数会去掉&lt;list&gt;中相同的单词。- **取单词函数——word**语法：`$(word &lt;n&gt;,&lt;text&gt; )`功能：取字符串&lt;text&gt;中第&lt;n&gt;个单词。（从一开始）返回：返回字符串&lt;text&gt;中第&lt;n&gt;个单词。如果&lt;n&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。示例：$(word2,foobarbaz)返回值是“bar”- **取单词串函数——wordlist**功能：从字符串&lt;text&gt;中取从&lt;s&gt;开始到&lt;e&gt;的单词串。&lt;s&gt;和&lt;e&gt;是一个数字。返回：返回字符串&lt;text&gt;中从&lt;s&gt;到&lt;e&gt;的单词字串。如果&lt;s&gt;比&lt;text&gt;中的单词数要大，那么返回空字符串。如果&lt;e&gt;大于&lt;text&gt;的单词数，那么返回从&lt;s&gt;开始，到&lt;text&gt;结束的单词串。示例：$(wordlist2,3,foobarbaz)返回值是“barbaz”3. 功能方面- **在规则中使用通配符**make支持三各通配符：`*，?，[...]`。（1）~波浪号`~`字符在文件名中也有比较特殊的用途。如果是`~/test`，这就表示当前用户的$HOME目录下的test目录。而`~hchen/test`则表示用户hchen的宿主目录下的test目录。（这些都是Unix下的小知识了，make也支持）而在Windows或是MS-DOS下，用户没有宿主目录，那么波浪号所指的目录则根据环境变量“`HOME`”而定。（2）*通配符代替了你一系列的文件，如`*.c`表示所以后缀为c的文件。一个需要我们注意的是，如果我们的文件名中有通配符，如：`*`，那么可以用转义字符`\\`，如`\\*`来表示真实的`*`字符，而不是任意长度的字符串。好吧，还是先来看几个例子吧： clean: rm -f *.o12上面这个例子我不不多说了，这是操作系统Shell所支持的通配符。这是在命令中的通配符。 print: *.c lpr -p $? touch print12 上面这个例子说明了通配符也可以在我们的规则中，目标print依赖于所有的`[.c]`文件。其中的“`$?`”是一个自动化变量。 objects = *.o12上面这个例子，表示了，通符同样可以用在变量中。并不是说`[*.o]`会展开，不！`objects`的值就是`*.o`。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让`objects`的值是所有`[.o]`的文件名的集合，那么，你可以这样： objects := $(wildcard *.o)123456- **文件搜寻**在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。Makefile文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当当前目录找不到的情况下，到所指定的目录中去找寻文件了。 VPATH = src:../headers123456789101112上面的的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：- `vpath &lt; pattern&gt; &lt; directories&gt;` 为符合模式&lt; pattern&gt;的文件指定搜索目录&lt;directories&gt;。- `vpath &lt; pattern&gt; ` 清除符合模式&lt; pattern&gt;的文件的搜索目录。- `vpath ` 清除所有已被设置好了的文件搜索目录。vapth使用方法中的&lt; pattern&gt;需要包含“%”字符。“%”的意思是匹配零或若干字符，例如，“%.h”表示所有以“.h”结尾的文件。&lt; pattern&gt;指定了要搜索的文件集，而&lt; directories&gt;则指定了的文件集的搜索的目录。例如： vpath %.h ../headers1234该语句表示，要求make在“../headers”目录下搜索所有以“.h”结尾的文件。（如果某文件在当前目录没有找到的话）我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt; pattern&gt;，或是被重复了的&lt; pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。如： vpath %.c foo vpath % blish vpath %.c bar12其表示“.c”结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。 vpath %.c foo:bar vpath % blish123456而上面的语句则表示“.c”结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录- **伪目标**最早先的一个例子中，我们提到过一个“clean”的目标，这是一个“伪目标”， clean: rm *.o temp 123456正像我们前面例子中的“clean”一样，即然我们生成了许多文件编译文件，我们也应该提供一个清除它们的“目标”以备完整地重编译而用。 （以“make clean”来使用该目标）因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显示地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显示地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 .PHONY : clean12只要有这个声明，不管是否有“clean”文件，要运行“clean”这个目标，只有“make clean”这样。于是整个过程可以这样写： .PHONY: clean clean: rm *.o temp 12伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性： all : prog1 prog2 prog3 .PHONY : all prog1 : prog1.o utils.o cc -o prog1 prog1.o utils.o prog2 : prog2.o cc -o prog2 prog2.o prog3 : prog3.o sort.o utils.o cc -o prog3 prog3.o sort.o utils.o1234我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它三个目标。由于伪目标的特性是，总是被执行的，所以其依赖的那三个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达到了我们一口气生成多个目标的目的。“.PHONY : all”声明了“all”这个目标为“伪目标”。随便提一句，从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子： .PHONY: cleanall cleanobj cleandiff cleanall : cleanobj cleandiff rm program cleanobj : rm .o cleandiff : rm .diff123456“makeclean”将清除所有要被清除的文件。“cleanobj”和“cleandiff”这两个伪目标有点像“子程序”的意思。我们可以输入“makecleanall”和“make cleanobj”和“makecleandiff”命令来达到清除不同种类文件的目的- **多目标**Makefile的规则中的目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。当然，多个目标的生成规则的执行命令是同一个，这可能会可我们带来麻烦，不过好在我们的可以使用一个自动化变量“$@”（关于自动化变量，将在后面讲述），这个变量表示着目前规则中所有的目标的集合，这样说可能很抽象，还是看一个例子吧。 bigoutput littleoutput : text.g generate text.g -$(subst output,,$@) &gt; $@ 12上述规则等价于： bigoutput : text.g generate text.g -big &gt; bigoutput littleoutput : text.g generate text.g -little &gt; littleoutput 123456其中，`-$(subst output,,$@) `中的“$”表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是截取字符串的意思，“$@”表示目标的集合，就像一个数组，“$@”依次取出目标，并执于命令。- **静态模式**静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法： &lt;targets…&gt;: : …123456789101112targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。target-parrtern是指明了targets的模式，也就是的目标集模式。prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。这样描述这三个东西，可能还是没有说清楚，还是举个例子来说明一下吧。如果我们的&lt;target-parrtern&gt;定义成“%.o”，意思是我们的集合中都是以“.o”结尾的，而如果我们的&lt;prereq-parrterns&gt;定义成“%.c”，意思是对&lt;target-parrtern&gt;所形成的目标集进行二次定义，其计算方法是，取&lt;target-parrtern&gt;模式中的“%”（也就是去掉了[.o]这个结尾），并为其加上[.c]这个结尾，形成的新集合。所以，我们的“目标模式”或是“依赖模式”中都应该有“%”这个字符，如果你的文件名中有“%”那么你可以使用反斜杠“\\”进行转义，来标明真实的“%”字符。看一个例子： objects = foo.o bar.o all: $(objects) $(objects): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@123 上面的例子中，指明了我们的目标从$object中获取，“%.o”表明要所有以“.o”结尾的目标，也就是“foo.o bar.o”，也就是变量$object集合的模式，而依赖模式“%.c”则取模式“%.o”的“%”，也就是“foobar”，并为其加下“.c”的后缀，于是，我们的依赖目标就是“foo.cbar.c”。而命令中的“$&lt;”和“$@”则是自动化变量，“$&lt;”表示所有的依赖目标集（也就是“foo.c bar.c”），“$@”表示目标集（也褪恰癴oo.o bar.o”）。于是，上面的规则展开后等价于下面的规则： foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.o bar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 1试想，如果我们的“%.o”有几百个，那种我们只要用这种很简单的“静态模式规则”就可以写完一堆规则，实在是太有效率了。“静态模式规则”的用法很灵活，如果用得好，那会一个很强大的功能。再看一个例子： files = foo.elc bar.o lose.o $(filter %.o,$(files)): %.o: %.c $(CC) -c $(CFLAGS) $&lt; -o $@ $(filter %.elc,$(files)): %.elc: %.el emacs -f batch-byte-compile $&lt;123456$(filter%.o,$(files))表示调用Makefile的filter函数，过滤“$filter”集，只要其中模式为“%.o”的内容。其的它内容，我就不用多说了吧。这个例字展示了Makefile中更大的弹性。- **自动生成依赖性**在Makefile中，我们的依赖关系可能会需要包含一系列的头文件，比如，如果我们的main.c中有一句“#include &quot;defs.h&quot;”，那么我们的依赖关系应该是： main.o : main.c defs.h12但是，如果是一个比较大型的工程，你必需清楚哪些C文件包含了哪些头文件，并且，你在加入或删除头文件时，也需要小心地修改Makefile，这是一个很没有维护性的工作。为了避免这种繁重而又容易出错的事情，我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令： cc -M main.c12其输出是： main.o : main.c defs.h1234于是由编译器自动生成的依赖关系，这样一来，你就不必再手动书写若干文件的依赖关系，而由编译器自动生成了。需要提醒一句的是，如果你使用GNU的C/C++编译器，你得用“-MM”参数，不然，“-M”参数会把一些标准库的头文件也包含进来。gcc-M main.c的输出是： main.o: main.c defs.h /usr/include/stdio.h /usr/include/features.h \\ /usr/include/sys/cdefs.h /usr/include/gnu/stubs.h \\ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stddef.h \\ /usr/include/bits/types.h /usr/include/bits/pthreadtypes.h \\ /usr/include/bits/sched.h /usr/include/libio.h \\ /usr/include/_G_config.h /usr/include/wchar.h \\ /usr/include/bits/wchar.h /usr/include/gconv.h \\ /usr/lib/gcc-lib/i486-suse-linux/2.95.3/include/stdarg.h \\ /usr/include/bits/stdio_lim.h 123 gcc -MM main.c的输出则是： main.o: main.c defs.h123456那么，编译器的这个功能如何与我们的Makefile联系在一起呢。因为这样一来，我们的Makefile也要根据这些源文件重新生成，让Makefile自已依赖于源文件？这个功能并不现实，不过我们可以有其它手段来迂回地实现这一功能。GNU组织建议把编译器为每一个源文件的自动生成的依赖关系放到一个文件中，为每一个“name.c”的文件都生成一个“name.d”的Makefile文件，[.d]文件中就存放对应[.c]文件的依赖关系。于是，我们可以写出[.c]文件和[.d]文件的依赖关系，并让make自动更新或自成[.d]文件，并把其包含在我们的主Makefile中，这样，我们就可以自动化地生成每个文件的依赖关系了。这里，我们给出了一个模式规则来产生[.d]文件： %.d: %.c @set -e; rm -f $@; \\ $(CC) -M $(CPPFLAGS) $&lt; &gt; $@. ; \\ sed &apos;s,$∗\\.o[ :]*,\\1.o $@ : ,g&apos; &lt; $@. $@; \\ rm -f $@. 12345这个规则的意思是，所有的[.d]文件依赖于[.c]文件，“rm-f $@”的意思是删除所有的目标，也就是[.d]文件，第二行的意思是，为每个依赖文件“$&lt;”，也就是[.c]文件生成依赖文件，“$@”表示模式“%.d”文件，如果有一个C文件是name.c，那么“%”就是“name”，“”意为一个随机编号，第二行生成的文件有可能是“name.d.12345”，第三行使用sed命令做了一个替换，关于sed命令的用法请参看相关的使用文档。第四行就是删除临时文件。总而言之，这个模式要做的事就是在编译器生成的依赖关系中加入[.d]文件的依赖，即把依赖关系： main.o : main.c defs.h12转成： main.o main.d : main.c defs.h1于是，我们的[.d]文件也会自动更新了，并会自动生成了，当然，你还可以在这个[.d]文件中加入的不只是依赖关系，包括生成的命令也可一并加入，让每个[.d]文件都包含一个完赖的规则。一旦我们完成这个工作，接下来，我们就要把这些自动生成的规则放进我们的主Makefile中。我们可以使用Makefile的“include”命令，来引入别的Makefile文件（前面讲过），例如： sources = foo.c bar.c1 include $(sources:.c=.d)123456上述语句中的“$(sources:.c=.d)”中的“.c=.d”的意思是做一个替换，把变量$(sources)所有[.c]的字串都替换成[.d]，关于这个“替换”的内容，在后面我会有更为详细的讲述。当然，你得注意次序，因为include是按次来载入文件，最先载入的[.d]文件中的目标会成为默认目标- **清空目标文件的规则**每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是： clean: rm edit $(objects) 12更为稳健的做法是： .PHONY : clean clean : -rm edit $(objects) 123456789101112131415161718192021222324252627282930313233343536373839.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。### 编译规则- 如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。- 如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。- 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。---## makefile的运行1、make的退出码0 ：表示成功执行。1 ：如果make运行时出现任何错误，其返回1。2 ：如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，那么返回2。2、指定Makefile3、指定目标4、检查规则5、make的参数---## 总结1. 命令行一定要以`tab`进行缩进---## 示例1. 示例一 test:main.o base.o g++ -o test main.o base.o main.o:main.cpp base.hpp gcc -c main.cpp base.o:base.cpp base.hpp gcc -c base.cpp .PHONY:clean clean: rm test main.o base.o 12345678解释：（1）test为生成的可执行文件的名称，即make makefile后生成的test可执行文件（2）如果语言是C++，则要使用g++来进行编译和链接（3）命令行只能使用tab来缩进，不能使用空格等2. 示例二 obj=main.o base.o test:$(obj) g++ -o test $(obj) main.o:base.hpp base.o:base.hpp .PHONY:clean clean: rm test $(obj) ` 参考文章–&gt; 文章1","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"makefile","slug":"makefile","permalink":"https://blog.xtcgch.ink/tags/makefile/"},{"name":"编译","slug":"编译","permalink":"https://blog.xtcgch.ink/tags/编译/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】回调函数","slug":"20181122-回调","date":"2018-11-23T08:00:00.000Z","updated":"2020-11-22T02:40:23.172Z","comments":true,"path":"callback-function/","link":"","permalink":"https://blog.xtcgch.ink/callback-function/","excerpt":"","text":"摘要：回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。 1、同步调用同步调用是一种阻塞式调用，调用方要等待对方执行完毕才返回，它是一种单向调用 2、异步调用异步调用是一种类似消息或事件的机制，不过它的调用方向刚好相反，接口的服务在收到某种讯息或发生某种事件时，会主动通知客户方（即调用客户方的接口） —&gt; 文章1—&gt; 文章2 3、回调回调是一种双向调用模式，也就是说，被调用方在接口被调用时也会调用对方的接口 附：回调和异步调用的关系非常紧密，通常我们使用回调来实现异步消息的注册，通过异步调用来实现消息的通知","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"回调","slug":"回调","permalink":"https://blog.xtcgch.ink/tags/回调/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]},{"title":"【原理】常见排序算法","slug":"20181122-排序","date":"2018-11-22T14:49:27.000Z","updated":"2020-11-22T02:40:27.089Z","comments":true,"path":"sort-alogrithm/","link":"","permalink":"https://blog.xtcgch.ink/sort-alogrithm/","excerpt":"本文主要介绍常见的七大排序方法，并且经过了优化，例子是C++版本，在vs1015中经过测试，全部通过，可以直接使用。","text":"本文主要介绍常见的七大排序方法，并且经过了优化，例子是C++版本，在vs1015中经过测试，全部通过，可以直接使用。 1、冒泡排序12345678910111213141516171819void bubble(vector&lt;int&gt; &amp;v)&#123; int flag = 1; int len = v.size(); for(int i = 0; i &lt; len &amp;&amp; flag == 1; i++) &#123; flag = 0; for(int j = len - 1; j &gt; i; j--) &#123; if(v[j - 1] &gt; v[j]) &#123; int temp = v[j]; v[j] = v[j - 1]; v[j - 1] = temp; flag = 1; &#125; &#125; &#125;&#125; 2、选择排序123456789101112131415161718192021222324252627void select(vector&lt;int&gt; &amp;v)&#123; int len = v.size(); if(len == 0) &#123; return; &#125; register int i, j, min, m; for(i = 0; i &lt; len - 1; i++) &#123; min = i;//²éÕÒ×îÐ¡Öµ for(j = i + 1; j &lt; len; j++) &#123; if(v[min] &gt; v[j]) &#123; min = j; &#125; &#125; if(min != i) &#123; swap(v[min], v[i]); cout &lt;&lt; &quot;第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;次排序结果是：&quot; &lt;&lt; endl; copy(v.begin(), v.end(), ostream_iterator&lt;int, char&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; &#125; &#125;&#125; 3、简单插入排序12345678910111213void insert(vector&lt;int&gt; &amp;v)&#123; for(int i = 1; i &lt; v.size(); i++) &#123; int j = i - 1; int data = v[i]; for(; j &gt;= 0 &amp;&amp; data &lt; v[j]; j--) &#123; v[j + 1] = v[j]; &#125; v[j + 1] = data; &#125;&#125; 4、希尔排序123456789101112131415161718192021void shell(vector&lt;int&gt; &amp;v)&#123; int h = 1, len = v.size(); while(h &lt; len)//»ñÈ¡ÔöÁ¿ h = 3 * h + 1; while(h &gt; 0) &#123; for(int j = h; j &lt; len; j++) &#123; int key = v[j]; int i = j - h; while(i &gt;= 0 &amp;&amp; v[i] &gt; key) &#123; v[i + h] = v[i]; i = i - h; &#125; v[i + h] = key; &#125; h = h / 3; &#125;&#125; 5、快速排序12345678910111213141516171819202122232425int partion(vector&lt;int&gt; &amp; v, int low, int high)&#123; int pivot, m; m = low + (high - low) / 2; if(v[low] &gt; v[high]) swap(v[low], v[high]); if(v[m] &gt; v[high]) swap(v[m], v[high]); if(v[m] &gt; v[low]) swap(v[m], v[low]); pivot = v[low]; while(low &lt; high) &#123; while(low &lt; high &amp;&amp; v[high] &gt;= pivot) high--; v[low] = v[high]; while(low &lt; high &amp;&amp; v[low] &lt;= pivot) low++; v[high] = v[low]; &#125; v[low] = pivot; return low;&#125; //尾排12345678910void qsort(vector&lt;int&gt; &amp; v, int low, int high)&#123; int pivot; if(low &lt; high) &#123; pivot = partion(v, low, high); qsort(v, low, pivot - 1); qsort(v, pivot + 1, high); &#125;&#125; //尾排12345678910111213141516void qsort1(vector&lt;int&gt; &amp; v, int low, int high)&#123; int pivot; while(low &lt; high) &#123; pivot = partion(v, low, high); qsort1(v, low, pivot - 1); low = pivot + 1; &#125;&#125;void quick(vector&lt;int&gt; &amp; v)&#123; qsort1(v, 0, v.size() - 1);&#125; 6、堆排序12345678910111213141516171819202122232425262728293031323334353637void adjustHeap(vector&lt;int&gt; &amp;arrs, int ParentKey, int len)&#123; int ParentValue = arrs[ParentKey]; int ChildKey = 2 * ParentKey + 1; while(ChildKey &lt; len) &#123; if(ChildKey + 1 &lt; len&amp;&amp;arrs[ChildKey] &lt; arrs[ChildKey + 1]) &#123; ChildKey++; //½Ï´óº¢×ÓµÄÏÂ±ê &#125; if(ParentValue &lt; arrs[ChildKey]) &#123; arrs[ParentKey] = arrs[ChildKey]; ParentKey = ChildKey; ChildKey = 2 * ParentKey + 1; &#125; else break; &#125; arrs[ParentKey] = ParentValue;&#125;void heapSort(vector&lt;int&gt; &amp;arrs, int len)&#123; for(int i = arrs.size() / 2 - 1; i &gt;= 0; i--) adjustHeap(arrs, i, arrs.size()); for(int i = arrs.size() - 1; i &gt;= 0; i--) &#123; //Êä³ö¸ù½Úµã int maxEle = arrs[0]; arrs[0] = arrs[i]; arrs[i] = maxEle; adjustHeap(arrs, 0, i); &#125;&#125; 7、归并排序12345678910111213141516171819202122232425262728293031323334//归并排序void Merge(vector&lt;int&gt; &amp;a, int low, int mid, int high, vector&lt;int&gt; &amp;temp)&#123; int i, j, k; i = low; j = mid + 1; k = 0; while(i &lt;= mid &amp;&amp; j &lt;= high) &#123; if(a[i] &lt;= a[j]) temp[k++] = a[i++]; else temp[k++] = a[j++]; &#125; while(i &lt;= mid) temp[k++] = a[i++]; while(j &lt;= high) temp[k++] = a[j++]; for(i = 0; i &lt; k; i++) a[low + i] = temp[i]; &#125;//接口函数void MergeSort(vector&lt;int&gt; &amp;data, int low, int high, vector&lt;int&gt; &amp;result)&#123; if(low &lt; high) &#123; int mid = (low + high) / 2; MergeSort(data, low, mid, result); MergeSort(data, mid + 1, high, result); Merge(data, low, mid, high, result); &#125;&#125;","categories":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.xtcgch.ink/tags/算法/"},{"name":"排序","slug":"排序","permalink":"https://blog.xtcgch.ink/tags/排序/"}],"keywords":[{"name":"代码","slug":"代码","permalink":"https://blog.xtcgch.ink/categories/代码/"}]},{"title":"【原理】HTTP基本知识","slug":"20181122-http基础知识","date":"2018-11-22T05:15:06.000Z","updated":"2020-11-22T02:37:11.209Z","comments":true,"path":"http-knowledge/","link":"","permalink":"https://blog.xtcgch.ink/http-knowledge/","excerpt":"http应该是每个做过网络编程的程序员都应该去了解的一个协议，只是根据自身业务和职业方向来决定是否深入专研还是浅尝辄止。对于我来说，只需要初步理解http的原理就可以了。","text":"http应该是每个做过网络编程的程序员都应该去了解的一个协议，只是根据自身业务和职业方向来决定是否深入专研还是浅尝辄止。对于我来说，只需要初步理解http的原理就可以了。 简介 HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。 HTTP基于TCP/IP通信协议来传递数据。 HTTP基于客户端/服务端（C/S）架构模型，通过一个可靠的链接来交换信息，是一个无状态的请求/响应协议。 请求体 请求方法 HEAD: 仅请求响应首部 GET: 完整请求一个资源 （常用 PUT: (webdav) 上传文件（但是浏览器不支持该方法） POST：提交表单 （常用） DELETE：(webdav) 删除 TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出） OPTIONS：返回请求的资源所支持的方法的方法 状态码1xx: 信息性状态码,表示服务器已接收了客户端请求，客户端可继续发送请求 1100, 101 2xx: 成功状态码, 1200：OK 3xx: 重定向状态码,表示服务器要求客户端重定向 12345301: 永久重定向, Location响应首部的值仍为当前URL，因此为隐藏重定向;302: 临时重定向，显式重定向, Location响应首部的值为新的URL304：Not Modified 未修改，比如本地缓存的资源文件和服务器上比较时，发现并没有修改，服务器返回一个304状态码，告诉浏览器，你不用请求该资源，直接使用本地的资源即可。 附注： 服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问http://www.facebook.com/而非http://facebook.com/。 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？ 其中一个原因跟搜索引擎排名有关。 如果一个页面有两个地址，就像http://www.igoro.com/和http://igoro.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。 而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。 还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。 4xx: 客户端错误状态码，表示客户端的请求有非法内容 1234567400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 404: Not Found 请求的URL资源并不存在 5xx: 服务器端错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误 12345500: Internal Server Error 服务器内部错误502: Bad Gateway 前面代理服务器联系不到后端的服务器时出现504：Gateway Timeout 这个是代理能联系到后端的服务器，但是后端的服务器在规定的时间内没有给代理服务器响应 请求过程1、域名解析 2、浏览器与web服务器建立一个 TCP 连接 3、浏览器给Web服务器发送一个http请求 4、服务器的永久重定向响应 考虑代理服务器的重定向 考虑路由器的重定向 5、浏览器跟踪重定向地址 6、服务器“处理”请求 考虑缓存 7、服务器发回一个HTML响应 8、客户端浏览器解析HTML内容 9、浏览器获取嵌入在HTML中的对象","categories":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://blog.xtcgch.ink/tags/前端/"},{"name":"http","slug":"http","permalink":"https://blog.xtcgch.ink/tags/http/"},{"name":"网络","slug":"网络","permalink":"https://blog.xtcgch.ink/tags/网络/"}],"keywords":[{"name":"原理","slug":"原理","permalink":"https://blog.xtcgch.ink/categories/原理/"}]}]}